(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~index"],{

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IF90eXBlb2YyKG9iaik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/jquery.transit/jquery.transit.js":
/*!*******************************************************!*\
  !*** ./node_modules/jquery.transit/jquery.transit.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery Transit - CSS3 transitions and transformations\n * (c) 2011-2014 Rico Sta. Cruz\n * MIT Licensed.\n *\n * http://ricostacruz.com/jquery.transit\n * http://github.com/rstacruz/jquery.transit\n */\n\n/* jshint expr: true */\n\n;(function (root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js-exposed\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}(this, function($) {\n\n  $.transit = {\n    version: \"0.9.12\",\n\n    // Map of $.css() keys to values for 'transitionProperty'.\n    // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated\n    propertyMap: {\n      marginLeft    : 'margin',\n      marginRight   : 'margin',\n      marginBottom  : 'margin',\n      marginTop     : 'margin',\n      paddingLeft   : 'padding',\n      paddingRight  : 'padding',\n      paddingBottom : 'padding',\n      paddingTop    : 'padding'\n    },\n\n    // Will simply transition \"instantly\" if false\n    enabled: true,\n\n    // Set this to false if you don't want to use the transition end property.\n    useTransitionEnd: false\n  };\n\n  var div = document.createElement('div');\n  var support = {};\n\n  // Helper function to get the proper vendor property name.\n  // (`transition` => `WebkitTransition`)\n  function getVendorPropertyName(prop) {\n    // Handle unprefixed versions (FF16+, for example)\n    if (prop in div.style) return prop;\n\n    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];\n    var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);\n\n    for (var i=0; i<prefixes.length; ++i) {\n      var vendorProp = prefixes[i] + prop_;\n      if (vendorProp in div.style) { return vendorProp; }\n    }\n  }\n\n  // Helper function to check if transform3D is supported.\n  // Should return true for Webkits and Firefox 10+.\n  function checkTransform3dSupport() {\n    div.style[support.transform] = '';\n    div.style[support.transform] = 'rotateY(90deg)';\n    return div.style[support.transform] !== '';\n  }\n\n  var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;\n\n  // Check for the browser's transitions support.\n  support.transition      = getVendorPropertyName('transition');\n  support.transitionDelay = getVendorPropertyName('transitionDelay');\n  support.transform       = getVendorPropertyName('transform');\n  support.transformOrigin = getVendorPropertyName('transformOrigin');\n  support.filter          = getVendorPropertyName('Filter');\n  support.transform3d     = checkTransform3dSupport();\n\n  var eventNames = {\n    'transition':       'transitionend',\n    'MozTransition':    'transitionend',\n    'OTransition':      'oTransitionEnd',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'msTransition':     'MSTransitionEnd'\n  };\n\n  // Detect the 'transitionend' event needed.\n  var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;\n\n  // Populate jQuery's `$.support` with the vendor prefixes we know.\n  // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),\n  // we set $.support.transition to a string of the actual property name used.\n  for (var key in support) {\n    if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {\n      $.support[key] = support[key];\n    }\n  }\n\n  // Avoid memory leak in IE.\n  div = null;\n\n  // ## $.cssEase\n  // List of easing aliases that you can use with `$.fn.transition`.\n  $.cssEase = {\n    '_default':       'ease',\n    'in':             'ease-in',\n    'out':            'ease-out',\n    'in-out':         'ease-in-out',\n    'snap':           'cubic-bezier(0,1,.5,1)',\n    // Penner equations\n    'easeInCubic':    'cubic-bezier(.550,.055,.675,.190)',\n    'easeOutCubic':   'cubic-bezier(.215,.61,.355,1)',\n    'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',\n    'easeInCirc':     'cubic-bezier(.6,.04,.98,.335)',\n    'easeOutCirc':    'cubic-bezier(.075,.82,.165,1)',\n    'easeInOutCirc':  'cubic-bezier(.785,.135,.15,.86)',\n    'easeInExpo':     'cubic-bezier(.95,.05,.795,.035)',\n    'easeOutExpo':    'cubic-bezier(.19,1,.22,1)',\n    'easeInOutExpo':  'cubic-bezier(1,0,0,1)',\n    'easeInQuad':     'cubic-bezier(.55,.085,.68,.53)',\n    'easeOutQuad':    'cubic-bezier(.25,.46,.45,.94)',\n    'easeInOutQuad':  'cubic-bezier(.455,.03,.515,.955)',\n    'easeInQuart':    'cubic-bezier(.895,.03,.685,.22)',\n    'easeOutQuart':   'cubic-bezier(.165,.84,.44,1)',\n    'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',\n    'easeInQuint':    'cubic-bezier(.755,.05,.855,.06)',\n    'easeOutQuint':   'cubic-bezier(.23,1,.32,1)',\n    'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',\n    'easeInSine':     'cubic-bezier(.47,0,.745,.715)',\n    'easeOutSine':    'cubic-bezier(.39,.575,.565,1)',\n    'easeInOutSine':  'cubic-bezier(.445,.05,.55,.95)',\n    'easeInBack':     'cubic-bezier(.6,-.28,.735,.045)',\n    'easeOutBack':    'cubic-bezier(.175, .885,.32,1.275)',\n    'easeInOutBack':  'cubic-bezier(.68,-.55,.265,1.55)'\n  };\n\n  // ## 'transform' CSS hook\n  // Allows you to use the `transform` property in CSS.\n  //\n  //     $(\"#hello\").css({ transform: \"rotate(90deg)\" });\n  //\n  //     $(\"#hello\").css('transform');\n  //     //=> { rotate: '90deg' }\n  //\n  $.cssHooks['transit:transform'] = {\n    // The getter returns a `Transform` object.\n    get: function(elem) {\n      return $(elem).data('transform') || new Transform();\n    },\n\n    // The setter accepts a `Transform` object or a string.\n    set: function(elem, v) {\n      var value = v;\n\n      if (!(value instanceof Transform)) {\n        value = new Transform(value);\n      }\n\n      // We've seen the 3D version of Scale() not work in Chrome when the\n      // element being scaled extends outside of the viewport.  Thus, we're\n      // forcing Chrome to not use the 3d transforms as well.  Not sure if\n      // translate is affectede, but not risking it.  Detection code from\n      // http://davidwalsh.name/detecting-google-chrome-javascript\n      if (support.transform === 'WebkitTransform' && !isChrome) {\n        elem.style[support.transform] = value.toString(true);\n      } else {\n        elem.style[support.transform] = value.toString();\n      }\n\n      $(elem).data('transform', value);\n    }\n  };\n\n  // Add a CSS hook for `.css({ transform: '...' })`.\n  // In jQuery 1.8+, this will intentionally override the default `transform`\n  // CSS hook so it'll play well with Transit. (see issue #62)\n  $.cssHooks.transform = {\n    set: $.cssHooks['transit:transform'].set\n  };\n\n  // ## 'filter' CSS hook\n  // Allows you to use the `filter` property in CSS.\n  //\n  //     $(\"#hello\").css({ filter: 'blur(10px)' });\n  //\n  $.cssHooks.filter = {\n    get: function(elem) {\n      return elem.style[support.filter];\n    },\n    set: function(elem, value) {\n      elem.style[support.filter] = value;\n    }\n  };\n\n  // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not\n  // be necessary.\n  if ($.fn.jquery < \"1.8\") {\n    // ## 'transformOrigin' CSS hook\n    // Allows the use for `transformOrigin` to define where scaling and rotation\n    // is pivoted.\n    //\n    //     $(\"#hello\").css({ transformOrigin: '0 0' });\n    //\n    $.cssHooks.transformOrigin = {\n      get: function(elem) {\n        return elem.style[support.transformOrigin];\n      },\n      set: function(elem, value) {\n        elem.style[support.transformOrigin] = value;\n      }\n    };\n\n    // ## 'transition' CSS hook\n    // Allows you to use the `transition` property in CSS.\n    //\n    //     $(\"#hello\").css({ transition: 'all 0 ease 0' });\n    //\n    $.cssHooks.transition = {\n      get: function(elem) {\n        return elem.style[support.transition];\n      },\n      set: function(elem, value) {\n        elem.style[support.transition] = value;\n      }\n    };\n  }\n\n  // ## Other CSS hooks\n  // Allows you to rotate, scale and translate.\n  registerCssHook('scale');\n  registerCssHook('scaleX');\n  registerCssHook('scaleY');\n  registerCssHook('translate');\n  registerCssHook('rotate');\n  registerCssHook('rotateX');\n  registerCssHook('rotateY');\n  registerCssHook('rotate3d');\n  registerCssHook('perspective');\n  registerCssHook('skewX');\n  registerCssHook('skewY');\n  registerCssHook('x', true);\n  registerCssHook('y', true);\n\n  // ## Transform class\n  // This is the main class of a transformation property that powers\n  // `$.fn.css({ transform: '...' })`.\n  //\n  // This is, in essence, a dictionary object with key/values as `-transform`\n  // properties.\n  //\n  //     var t = new Transform(\"rotate(90) scale(4)\");\n  //\n  //     t.rotate             //=> \"90deg\"\n  //     t.scale              //=> \"4,4\"\n  //\n  // Setters are accounted for.\n  //\n  //     t.set('rotate', 4)\n  //     t.rotate             //=> \"4deg\"\n  //\n  // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)\n  // functions.\n  //\n  //     t.toString()         //=> \"rotate(90deg) scale(4,4)\"\n  //     t.toString(true)     //=> \"rotate(90deg) scale3d(4,4,0)\" (WebKit version)\n  //\n  function Transform(str) {\n    if (typeof str === 'string') { this.parse(str); }\n    return this;\n  }\n\n  Transform.prototype = {\n    // ### setFromString()\n    // Sets a property from a string.\n    //\n    //     t.setFromString('scale', '2,4');\n    //     // Same as set('scale', '2', '4');\n    //\n    setFromString: function(prop, val) {\n      var args =\n        (typeof val === 'string')  ? val.split(',') :\n        (val.constructor === Array) ? val :\n        [ val ];\n\n      args.unshift(prop);\n\n      Transform.prototype.set.apply(this, args);\n    },\n\n    // ### set()\n    // Sets a property.\n    //\n    //     t.set('scale', 2, 4);\n    //\n    set: function(prop) {\n      var args = Array.prototype.slice.apply(arguments, [1]);\n      if (this.setter[prop]) {\n        this.setter[prop].apply(this, args);\n      } else {\n        this[prop] = args.join(',');\n      }\n    },\n\n    get: function(prop) {\n      if (this.getter[prop]) {\n        return this.getter[prop].apply(this);\n      } else {\n        return this[prop] || 0;\n      }\n    },\n\n    setter: {\n      // ### rotate\n      //\n      //     .css({ rotate: 30 })\n      //     .css({ rotate: \"30\" })\n      //     .css({ rotate: \"30deg\" })\n      //     .css({ rotate: \"30deg\" })\n      //\n      rotate: function(theta) {\n        this.rotate = unit(theta, 'deg');\n      },\n\n      rotateX: function(theta) {\n        this.rotateX = unit(theta, 'deg');\n      },\n\n      rotateY: function(theta) {\n        this.rotateY = unit(theta, 'deg');\n      },\n\n      // ### scale\n      //\n      //     .css({ scale: 9 })      //=> \"scale(9,9)\"\n      //     .css({ scale: '3,2' })  //=> \"scale(3,2)\"\n      //\n      scale: function(x, y) {\n        if (y === undefined) { y = x; }\n        this.scale = x + \",\" + y;\n      },\n\n      // ### skewX + skewY\n      skewX: function(x) {\n        this.skewX = unit(x, 'deg');\n      },\n\n      skewY: function(y) {\n        this.skewY = unit(y, 'deg');\n      },\n\n      // ### perspectvie\n      perspective: function(dist) {\n        this.perspective = unit(dist, 'px');\n      },\n\n      // ### x / y\n      // Translations. Notice how this keeps the other value.\n      //\n      //     .css({ x: 4 })       //=> \"translate(4px, 0)\"\n      //     .css({ y: 10 })      //=> \"translate(4px, 10px)\"\n      //\n      x: function(x) {\n        this.set('translate', x, null);\n      },\n\n      y: function(y) {\n        this.set('translate', null, y);\n      },\n\n      // ### translate\n      // Notice how this keeps the other value.\n      //\n      //     .css({ translate: '2, 5' })    //=> \"translate(2px, 5px)\"\n      //\n      translate: function(x, y) {\n        if (this._translateX === undefined) { this._translateX = 0; }\n        if (this._translateY === undefined) { this._translateY = 0; }\n\n        if (x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }\n        if (y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }\n\n        this.translate = this._translateX + \",\" + this._translateY;\n      }\n    },\n\n    getter: {\n      x: function() {\n        return this._translateX || 0;\n      },\n\n      y: function() {\n        return this._translateY || 0;\n      },\n\n      scale: function() {\n        var s = (this.scale || \"1,1\").split(',');\n        if (s[0]) { s[0] = parseFloat(s[0]); }\n        if (s[1]) { s[1] = parseFloat(s[1]); }\n\n        // \"2.5,2.5\" => 2.5\n        // \"2.5,1\" => [2.5,1]\n        return (s[0] === s[1]) ? s[0] : s;\n      },\n\n      rotate3d: function() {\n        var s = (this.rotate3d || \"0,0,0,0deg\").split(',');\n        for (var i=0; i<=3; ++i) {\n          if (s[i]) { s[i] = parseFloat(s[i]); }\n        }\n        if (s[3]) { s[3] = unit(s[3], 'deg'); }\n\n        return s;\n      }\n    },\n\n    // ### parse()\n    // Parses from a string. Called on constructor.\n    parse: function(str) {\n      var self = this;\n      str.replace(/([a-zA-Z0-9]+)\\((.*?)\\)/g, function(x, prop, val) {\n        self.setFromString(prop, val);\n      });\n    },\n\n    // ### toString()\n    // Converts to a `transition` CSS property string. If `use3d` is given,\n    // it converts to a `-webkit-transition` CSS property string instead.\n    toString: function(use3d) {\n      var re = [];\n\n      for (var i in this) {\n        if (this.hasOwnProperty(i)) {\n          // Don't use 3D transformations if the browser can't support it.\n          if ((!support.transform3d) && (\n            (i === 'rotateX') ||\n            (i === 'rotateY') ||\n            (i === 'perspective') ||\n            (i === 'transformOrigin'))) { continue; }\n\n          if (i[0] !== '_') {\n            if (use3d && (i === 'scale')) {\n              re.push(i + \"3d(\" + this[i] + \",1)\");\n            } else if (use3d && (i === 'translate')) {\n              re.push(i + \"3d(\" + this[i] + \",0)\");\n            } else {\n              re.push(i + \"(\" + this[i] + \")\");\n            }\n          }\n        }\n      }\n\n      return re.join(\" \");\n    }\n  };\n\n  function callOrQueue(self, queue, fn) {\n    if (queue === true) {\n      self.queue(fn);\n    } else if (queue) {\n      self.queue(queue, fn);\n    } else {\n      self.each(function () {\n                fn.call(this);\n            });\n    }\n  }\n\n  // ### getProperties(dict)\n  // Returns properties (for `transition-property`) for dictionary `props`. The\n  // value of `props` is what you would expect in `$.css(...)`.\n  function getProperties(props) {\n    var re = [];\n\n    $.each(props, function(key) {\n      key = $.camelCase(key); // Convert \"text-align\" => \"textAlign\"\n      key = $.transit.propertyMap[key] || $.cssProps[key] || key;\n      key = uncamel(key); // Convert back to dasherized\n\n      // Get vendor specify propertie\n      if (support[key])\n        key = uncamel(support[key]);\n\n      if ($.inArray(key, re) === -1) { re.push(key); }\n    });\n\n    return re;\n  }\n\n  // ### getTransition()\n  // Returns the transition string to be used for the `transition` CSS property.\n  //\n  // Example:\n  //\n  //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');\n  //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'\n  //\n  function getTransition(properties, duration, easing, delay) {\n    // Get the CSS properties needed.\n    var props = getProperties(properties);\n\n    // Account for aliases (`in` => `ease-in`).\n    if ($.cssEase[easing]) { easing = $.cssEase[easing]; }\n\n    // Build the duration/easing/delay attributes for it.\n    var attribs = '' + toMS(duration) + ' ' + easing;\n    if (parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }\n\n    // For more properties, add them this way:\n    // \"margin 200ms ease, padding 200ms ease, ...\"\n    var transitions = [];\n    $.each(props, function(i, name) {\n      transitions.push(name + ' ' + attribs);\n    });\n\n    return transitions.join(', ');\n  }\n\n  // ## $.fn.transition\n  // Works like $.fn.animate(), but uses CSS transitions.\n  //\n  //     $(\"...\").transition({ opacity: 0.1, scale: 0.3 });\n  //\n  //     // Specific duration\n  //     $(\"...\").transition({ opacity: 0.1, scale: 0.3 }, 500);\n  //\n  //     // With duration and easing\n  //     $(\"...\").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');\n  //\n  //     // With callback\n  //     $(\"...\").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });\n  //\n  //     // With everything\n  //     $(\"...\").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });\n  //\n  //     // Alternate syntax\n  //     $(\"...\").transition({\n  //       opacity: 0.1,\n  //       duration: 200,\n  //       delay: 40,\n  //       easing: 'in',\n  //       complete: function() { /* ... */ }\n  //      });\n  //\n  $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {\n    var self  = this;\n    var delay = 0;\n    var queue = true;\n\n    var theseProperties = $.extend(true, {}, properties);\n\n    // Account for `.transition(properties, callback)`.\n    if (typeof duration === 'function') {\n      callback = duration;\n      duration = undefined;\n    }\n\n    // Account for `.transition(properties, options)`.\n    if (typeof duration === 'object') {\n      easing = duration.easing;\n      delay = duration.delay || 0;\n      queue = typeof duration.queue === \"undefined\" ? true : duration.queue;\n      callback = duration.complete;\n      duration = duration.duration;\n    }\n\n    // Account for `.transition(properties, duration, callback)`.\n    if (typeof easing === 'function') {\n      callback = easing;\n      easing = undefined;\n    }\n\n    // Alternate syntax.\n    if (typeof theseProperties.easing !== 'undefined') {\n      easing = theseProperties.easing;\n      delete theseProperties.easing;\n    }\n\n    if (typeof theseProperties.duration !== 'undefined') {\n      duration = theseProperties.duration;\n      delete theseProperties.duration;\n    }\n\n    if (typeof theseProperties.complete !== 'undefined') {\n      callback = theseProperties.complete;\n      delete theseProperties.complete;\n    }\n\n    if (typeof theseProperties.queue !== 'undefined') {\n      queue = theseProperties.queue;\n      delete theseProperties.queue;\n    }\n\n    if (typeof theseProperties.delay !== 'undefined') {\n      delay = theseProperties.delay;\n      delete theseProperties.delay;\n    }\n\n    // Set defaults. (`400` duration, `ease` easing)\n    if (typeof duration === 'undefined') { duration = $.fx.speeds._default; }\n    if (typeof easing === 'undefined')   { easing = $.cssEase._default; }\n\n    duration = toMS(duration);\n\n    // Build the `transition` property.\n    var transitionValue = getTransition(theseProperties, duration, easing, delay);\n\n    // Compute delay until callback.\n    // If this becomes 0, don't bother setting the transition property.\n    var work = $.transit.enabled && support.transition;\n    var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;\n\n    // If there's nothing to do...\n    if (i === 0) {\n      var fn = function(next) {\n        self.css(theseProperties);\n        if (callback) { callback.apply(self); }\n        if (next) { next(); }\n      };\n\n      callOrQueue(self, queue, fn);\n      return self;\n    }\n\n    // Save the old transitions of each element so we can restore it later.\n    var oldTransitions = {};\n\n    var run = function(nextCall) {\n      var bound = false;\n\n      // Prepare the callback.\n      var cb = function() {\n        if (bound) { self.unbind(transitionEnd, cb); }\n\n        if (i > 0) {\n          self.each(function() {\n            this.style[support.transition] = (oldTransitions[this] || null);\n          });\n        }\n\n        if (typeof callback === 'function') { callback.apply(self); }\n        if (typeof nextCall === 'function') { nextCall(); }\n      };\n\n      if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {\n        // Use the 'transitionend' event if it's available.\n        bound = true;\n        self.bind(transitionEnd, cb);\n      } else {\n        // Fallback to timers if the 'transitionend' event isn't supported.\n        window.setTimeout(cb, i);\n      }\n\n      // Apply transitions.\n      self.each(function() {\n        if (i > 0) {\n          this.style[support.transition] = transitionValue;\n        }\n        $(this).css(theseProperties);\n      });\n    };\n\n    // Defer running. This allows the browser to paint any pending CSS it hasn't\n    // painted yet before doing the transitions.\n    var deferredRun = function(next) {\n        this.offsetWidth; // force a repaint\n        run(next);\n    };\n\n    // Use jQuery's fx queue.\n    callOrQueue(self, queue, deferredRun);\n\n    // Chainability.\n    return this;\n  };\n\n  function registerCssHook(prop, isPixels) {\n    // For certain properties, the 'px' should not be implied.\n    if (!isPixels) { $.cssNumber[prop] = true; }\n\n    $.transit.propertyMap[prop] = support.transform;\n\n    $.cssHooks[prop] = {\n      get: function(elem) {\n        var t = $(elem).css('transit:transform');\n        return t.get(prop);\n      },\n\n      set: function(elem, value) {\n        var t = $(elem).css('transit:transform');\n        t.setFromString(prop, value);\n\n        $(elem).css({ 'transit:transform': t });\n      }\n    };\n\n  }\n\n  // ### uncamel(str)\n  // Converts a camelcase string to a dasherized string.\n  // (`marginLeft` => `margin-left`)\n  function uncamel(str) {\n    return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });\n  }\n\n  // ### unit(number, unit)\n  // Ensures that number `number` has a unit. If no unit is found, assume the\n  // default is `unit`.\n  //\n  //     unit(2, 'px')          //=> \"2px\"\n  //     unit(\"30deg\", 'rad')   //=> \"30deg\"\n  //\n  function unit(i, units) {\n    if ((typeof i === \"string\") && (!i.match(/^[\\-0-9\\.]+$/))) {\n      return i;\n    } else {\n      return \"\" + i + units;\n    }\n  }\n\n  // ### toMS(duration)\n  // Converts given `duration` to a millisecond string.\n  //\n  // toMS('fast') => $.fx.speeds[i] => \"200ms\"\n  // toMS('normal') //=> $.fx.speeds._default => \"400ms\"\n  // toMS(10) //=> '10ms'\n  // toMS('100ms') //=> '100ms'  \n  //\n  function toMS(duration) {\n    var i = duration;\n\n    // Allow string durations like 'fast' and 'slow', without overriding numeric values.\n    if (typeof i === 'string' && (!i.match(/^[\\-0-9\\.]+/))) { i = $.fx.speeds[i] || $.fx.speeds._default; }\n\n    return unit(i, 'ms');\n  }\n\n  // Export some functions for testable-ness.\n  $.transit.getTransitionValue = getTransition;\n\n  return $;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnRyYW5zaXQvanF1ZXJ5LnRyYW5zaXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnRyYW5zaXQvanF1ZXJ5LnRyYW5zaXQuanM/NjIxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBUcmFuc2l0IC0gQ1NTMyB0cmFuc2l0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zXG4gKiAoYykgMjAxMS0yMDE0IFJpY28gU3RhLiBDcnV6XG4gKiBNSVQgTGljZW5zZWQuXG4gKlxuICogaHR0cDovL3JpY29zdGFjcnV6LmNvbS9qcXVlcnkudHJhbnNpdFxuICogaHR0cDovL2dpdGh1Yi5jb20vcnN0YWNydXovanF1ZXJ5LnRyYW5zaXRcbiAqL1xuXG4vKiBqc2hpbnQgZXhwcjogdHJ1ZSAqL1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuICB9IGVsc2Uge1xuICAgIGZhY3Rvcnkocm9vdC5qUXVlcnkpO1xuICB9XG5cbn0odGhpcywgZnVuY3Rpb24oJCkge1xuXG4gICQudHJhbnNpdCA9IHtcbiAgICB2ZXJzaW9uOiBcIjAuOS4xMlwiLFxuXG4gICAgLy8gTWFwIG9mICQuY3NzKCkga2V5cyB0byB2YWx1ZXMgZm9yICd0cmFuc2l0aW9uUHJvcGVydHknLlxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DU1MvQ1NTX3RyYW5zaXRpb25zI1Byb3BlcnRpZXNfdGhhdF9jYW5fYmVfYW5pbWF0ZWRcbiAgICBwcm9wZXJ0eU1hcDoge1xuICAgICAgbWFyZ2luTGVmdCAgICA6ICdtYXJnaW4nLFxuICAgICAgbWFyZ2luUmlnaHQgICA6ICdtYXJnaW4nLFxuICAgICAgbWFyZ2luQm90dG9tICA6ICdtYXJnaW4nLFxuICAgICAgbWFyZ2luVG9wICAgICA6ICdtYXJnaW4nLFxuICAgICAgcGFkZGluZ0xlZnQgICA6ICdwYWRkaW5nJyxcbiAgICAgIHBhZGRpbmdSaWdodCAgOiAncGFkZGluZycsXG4gICAgICBwYWRkaW5nQm90dG9tIDogJ3BhZGRpbmcnLFxuICAgICAgcGFkZGluZ1RvcCAgICA6ICdwYWRkaW5nJ1xuICAgIH0sXG5cbiAgICAvLyBXaWxsIHNpbXBseSB0cmFuc2l0aW9uIFwiaW5zdGFudGx5XCIgaWYgZmFsc2VcbiAgICBlbmFibGVkOiB0cnVlLFxuXG4gICAgLy8gU2V0IHRoaXMgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZSB0cmFuc2l0aW9uIGVuZCBwcm9wZXJ0eS5cbiAgICB1c2VUcmFuc2l0aW9uRW5kOiBmYWxzZVxuICB9O1xuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN1cHBvcnQgPSB7fTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBwcm9wZXIgdmVuZG9yIHByb3BlcnR5IG5hbWUuXG4gIC8vIChgdHJhbnNpdGlvbmAgPT4gYFdlYmtpdFRyYW5zaXRpb25gKVxuICBmdW5jdGlvbiBnZXRWZW5kb3JQcm9wZXJ0eU5hbWUocHJvcCkge1xuICAgIC8vIEhhbmRsZSB1bnByZWZpeGVkIHZlcnNpb25zIChGRjE2KywgZm9yIGV4YW1wbGUpXG4gICAgaWYgKHByb3AgaW4gZGl2LnN0eWxlKSByZXR1cm4gcHJvcDtcblxuICAgIHZhciBwcmVmaXhlcyA9IFsnTW96JywgJ1dlYmtpdCcsICdPJywgJ21zJ107XG4gICAgdmFyIHByb3BfID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyKDEpO1xuXG4gICAgZm9yICh2YXIgaT0wOyBpPHByZWZpeGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdmVuZG9yUHJvcCA9IHByZWZpeGVzW2ldICsgcHJvcF87XG4gICAgICBpZiAodmVuZG9yUHJvcCBpbiBkaXYuc3R5bGUpIHsgcmV0dXJuIHZlbmRvclByb3A7IH1cbiAgICB9XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdHJhbnNmb3JtM0QgaXMgc3VwcG9ydGVkLlxuICAvLyBTaG91bGQgcmV0dXJuIHRydWUgZm9yIFdlYmtpdHMgYW5kIEZpcmVmb3ggMTArLlxuICBmdW5jdGlvbiBjaGVja1RyYW5zZm9ybTNkU3VwcG9ydCgpIHtcbiAgICBkaXYuc3R5bGVbc3VwcG9ydC50cmFuc2Zvcm1dID0gJyc7XG4gICAgZGl2LnN0eWxlW3N1cHBvcnQudHJhbnNmb3JtXSA9ICdyb3RhdGVZKDkwZGVnKSc7XG4gICAgcmV0dXJuIGRpdi5zdHlsZVtzdXBwb3J0LnRyYW5zZm9ybV0gIT09ICcnO1xuICB9XG5cbiAgdmFyIGlzQ2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTE7XG5cbiAgLy8gQ2hlY2sgZm9yIHRoZSBicm93c2VyJ3MgdHJhbnNpdGlvbnMgc3VwcG9ydC5cbiAgc3VwcG9ydC50cmFuc2l0aW9uICAgICAgPSBnZXRWZW5kb3JQcm9wZXJ0eU5hbWUoJ3RyYW5zaXRpb24nKTtcbiAgc3VwcG9ydC50cmFuc2l0aW9uRGVsYXkgPSBnZXRWZW5kb3JQcm9wZXJ0eU5hbWUoJ3RyYW5zaXRpb25EZWxheScpO1xuICBzdXBwb3J0LnRyYW5zZm9ybSAgICAgICA9IGdldFZlbmRvclByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gIHN1cHBvcnQudHJhbnNmb3JtT3JpZ2luID0gZ2V0VmVuZG9yUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm1PcmlnaW4nKTtcbiAgc3VwcG9ydC5maWx0ZXIgICAgICAgICAgPSBnZXRWZW5kb3JQcm9wZXJ0eU5hbWUoJ0ZpbHRlcicpO1xuICBzdXBwb3J0LnRyYW5zZm9ybTNkICAgICA9IGNoZWNrVHJhbnNmb3JtM2RTdXBwb3J0KCk7XG5cbiAgdmFyIGV2ZW50TmFtZXMgPSB7XG4gICAgJ3RyYW5zaXRpb24nOiAgICAgICAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAgICAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogICAgICAnb1RyYW5zaXRpb25FbmQnLFxuICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdtc1RyYW5zaXRpb24nOiAgICAgJ01TVHJhbnNpdGlvbkVuZCdcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlICd0cmFuc2l0aW9uZW5kJyBldmVudCBuZWVkZWQuXG4gIHZhciB0cmFuc2l0aW9uRW5kID0gc3VwcG9ydC50cmFuc2l0aW9uRW5kID0gZXZlbnROYW1lc1tzdXBwb3J0LnRyYW5zaXRpb25dIHx8IG51bGw7XG5cbiAgLy8gUG9wdWxhdGUgalF1ZXJ5J3MgYCQuc3VwcG9ydGAgd2l0aCB0aGUgdmVuZG9yIHByZWZpeGVzIHdlIGtub3cuXG4gIC8vIEFzIHBlciBbalF1ZXJ5J3MgY3NzSG9va3MgZG9jdW1lbnRhdGlvbl0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5jc3NIb29rcy8pLFxuICAvLyB3ZSBzZXQgJC5zdXBwb3J0LnRyYW5zaXRpb24gdG8gYSBzdHJpbmcgb2YgdGhlIGFjdHVhbCBwcm9wZXJ0eSBuYW1lIHVzZWQuXG4gIGZvciAodmFyIGtleSBpbiBzdXBwb3J0KSB7XG4gICAgaWYgKHN1cHBvcnQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgJC5zdXBwb3J0W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAkLnN1cHBvcnRba2V5XSA9IHN1cHBvcnRba2V5XTtcbiAgICB9XG4gIH1cblxuICAvLyBBdm9pZCBtZW1vcnkgbGVhayBpbiBJRS5cbiAgZGl2ID0gbnVsbDtcblxuICAvLyAjIyAkLmNzc0Vhc2VcbiAgLy8gTGlzdCBvZiBlYXNpbmcgYWxpYXNlcyB0aGF0IHlvdSBjYW4gdXNlIHdpdGggYCQuZm4udHJhbnNpdGlvbmAuXG4gICQuY3NzRWFzZSA9IHtcbiAgICAnX2RlZmF1bHQnOiAgICAgICAnZWFzZScsXG4gICAgJ2luJzogICAgICAgICAgICAgJ2Vhc2UtaW4nLFxuICAgICdvdXQnOiAgICAgICAgICAgICdlYXNlLW91dCcsXG4gICAgJ2luLW91dCc6ICAgICAgICAgJ2Vhc2UtaW4tb3V0JyxcbiAgICAnc25hcCc6ICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAsMSwuNSwxKScsXG4gICAgLy8gUGVubmVyIGVxdWF0aW9uc1xuICAgICdlYXNlSW5DdWJpYyc6ICAgICdjdWJpYy1iZXppZXIoLjU1MCwuMDU1LC42NzUsLjE5MCknLFxuICAgICdlYXNlT3V0Q3ViaWMnOiAgICdjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKScsXG4gICAgJ2Vhc2VJbk91dEN1YmljJzogJ2N1YmljLWJlemllciguNjQ1LC4wNDUsLjM1NSwxKScsXG4gICAgJ2Vhc2VJbkNpcmMnOiAgICAgJ2N1YmljLWJlemllciguNiwuMDQsLjk4LC4zMzUpJyxcbiAgICAnZWFzZU91dENpcmMnOiAgICAnY3ViaWMtYmV6aWVyKC4wNzUsLjgyLC4xNjUsMSknLFxuICAgICdlYXNlSW5PdXRDaXJjJzogICdjdWJpYy1iZXppZXIoLjc4NSwuMTM1LC4xNSwuODYpJyxcbiAgICAnZWFzZUluRXhwbyc6ICAgICAnY3ViaWMtYmV6aWVyKC45NSwuMDUsLjc5NSwuMDM1KScsXG4gICAgJ2Vhc2VPdXRFeHBvJzogICAgJ2N1YmljLWJlemllciguMTksMSwuMjIsMSknLFxuICAgICdlYXNlSW5PdXRFeHBvJzogICdjdWJpYy1iZXppZXIoMSwwLDAsMSknLFxuICAgICdlYXNlSW5RdWFkJzogICAgICdjdWJpYy1iZXppZXIoLjU1LC4wODUsLjY4LC41MyknLFxuICAgICdlYXNlT3V0UXVhZCc6ICAgICdjdWJpYy1iZXppZXIoLjI1LC40NiwuNDUsLjk0KScsXG4gICAgJ2Vhc2VJbk91dFF1YWQnOiAgJ2N1YmljLWJlemllciguNDU1LC4wMywuNTE1LC45NTUpJyxcbiAgICAnZWFzZUluUXVhcnQnOiAgICAnY3ViaWMtYmV6aWVyKC44OTUsLjAzLC42ODUsLjIyKScsXG4gICAgJ2Vhc2VPdXRRdWFydCc6ICAgJ2N1YmljLWJlemllciguMTY1LC44NCwuNDQsMSknLFxuICAgICdlYXNlSW5PdXRRdWFydCc6ICdjdWJpYy1iZXppZXIoLjc3LDAsLjE3NSwxKScsXG4gICAgJ2Vhc2VJblF1aW50JzogICAgJ2N1YmljLWJlemllciguNzU1LC4wNSwuODU1LC4wNiknLFxuICAgICdlYXNlT3V0UXVpbnQnOiAgICdjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpJyxcbiAgICAnZWFzZUluT3V0UXVpbnQnOiAnY3ViaWMtYmV6aWVyKC44NiwwLC4wNywxKScsXG4gICAgJ2Vhc2VJblNpbmUnOiAgICAgJ2N1YmljLWJlemllciguNDcsMCwuNzQ1LC43MTUpJyxcbiAgICAnZWFzZU91dFNpbmUnOiAgICAnY3ViaWMtYmV6aWVyKC4zOSwuNTc1LC41NjUsMSknLFxuICAgICdlYXNlSW5PdXRTaW5lJzogICdjdWJpYy1iZXppZXIoLjQ0NSwuMDUsLjU1LC45NSknLFxuICAgICdlYXNlSW5CYWNrJzogICAgICdjdWJpYy1iZXppZXIoLjYsLS4yOCwuNzM1LC4wNDUpJyxcbiAgICAnZWFzZU91dEJhY2snOiAgICAnY3ViaWMtYmV6aWVyKC4xNzUsIC44ODUsLjMyLDEuMjc1KScsXG4gICAgJ2Vhc2VJbk91dEJhY2snOiAgJ2N1YmljLWJlemllciguNjgsLS41NSwuMjY1LDEuNTUpJ1xuICB9O1xuXG4gIC8vICMjICd0cmFuc2Zvcm0nIENTUyBob29rXG4gIC8vIEFsbG93cyB5b3UgdG8gdXNlIHRoZSBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBpbiBDU1MuXG4gIC8vXG4gIC8vICAgICAkKFwiI2hlbGxvXCIpLmNzcyh7IHRyYW5zZm9ybTogXCJyb3RhdGUoOTBkZWcpXCIgfSk7XG4gIC8vXG4gIC8vICAgICAkKFwiI2hlbGxvXCIpLmNzcygndHJhbnNmb3JtJyk7XG4gIC8vICAgICAvLz0+IHsgcm90YXRlOiAnOTBkZWcnIH1cbiAgLy9cbiAgJC5jc3NIb29rc1sndHJhbnNpdDp0cmFuc2Zvcm0nXSA9IHtcbiAgICAvLyBUaGUgZ2V0dGVyIHJldHVybnMgYSBgVHJhbnNmb3JtYCBvYmplY3QuXG4gICAgZ2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gJChlbGVtKS5kYXRhKCd0cmFuc2Zvcm0nKSB8fCBuZXcgVHJhbnNmb3JtKCk7XG4gICAgfSxcblxuICAgIC8vIFRoZSBzZXR0ZXIgYWNjZXB0cyBhIGBUcmFuc2Zvcm1gIG9iamVjdCBvciBhIHN0cmluZy5cbiAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHYpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHY7XG5cbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkge1xuICAgICAgICB2YWx1ZSA9IG5ldyBUcmFuc2Zvcm0odmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSd2ZSBzZWVuIHRoZSAzRCB2ZXJzaW9uIG9mIFNjYWxlKCkgbm90IHdvcmsgaW4gQ2hyb21lIHdoZW4gdGhlXG4gICAgICAvLyBlbGVtZW50IGJlaW5nIHNjYWxlZCBleHRlbmRzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LiAgVGh1cywgd2UncmVcbiAgICAgIC8vIGZvcmNpbmcgQ2hyb21lIHRvIG5vdCB1c2UgdGhlIDNkIHRyYW5zZm9ybXMgYXMgd2VsbC4gIE5vdCBzdXJlIGlmXG4gICAgICAvLyB0cmFuc2xhdGUgaXMgYWZmZWN0ZWRlLCBidXQgbm90IHJpc2tpbmcgaXQuICBEZXRlY3Rpb24gY29kZSBmcm9tXG4gICAgICAvLyBodHRwOi8vZGF2aWR3YWxzaC5uYW1lL2RldGVjdGluZy1nb29nbGUtY2hyb21lLWphdmFzY3JpcHRcbiAgICAgIGlmIChzdXBwb3J0LnRyYW5zZm9ybSA9PT0gJ1dlYmtpdFRyYW5zZm9ybScgJiYgIWlzQ2hyb21lKSB7XG4gICAgICAgIGVsZW0uc3R5bGVbc3VwcG9ydC50cmFuc2Zvcm1dID0gdmFsdWUudG9TdHJpbmcodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLnN0eWxlW3N1cHBvcnQudHJhbnNmb3JtXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgICQoZWxlbSkuZGF0YSgndHJhbnNmb3JtJywgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBDU1MgaG9vayBmb3IgYC5jc3MoeyB0cmFuc2Zvcm06ICcuLi4nIH0pYC5cbiAgLy8gSW4galF1ZXJ5IDEuOCssIHRoaXMgd2lsbCBpbnRlbnRpb25hbGx5IG92ZXJyaWRlIHRoZSBkZWZhdWx0IGB0cmFuc2Zvcm1gXG4gIC8vIENTUyBob29rIHNvIGl0J2xsIHBsYXkgd2VsbCB3aXRoIFRyYW5zaXQuIChzZWUgaXNzdWUgIzYyKVxuICAkLmNzc0hvb2tzLnRyYW5zZm9ybSA9IHtcbiAgICBzZXQ6ICQuY3NzSG9va3NbJ3RyYW5zaXQ6dHJhbnNmb3JtJ10uc2V0XG4gIH07XG5cbiAgLy8gIyMgJ2ZpbHRlcicgQ1NTIGhvb2tcbiAgLy8gQWxsb3dzIHlvdSB0byB1c2UgdGhlIGBmaWx0ZXJgIHByb3BlcnR5IGluIENTUy5cbiAgLy9cbiAgLy8gICAgICQoXCIjaGVsbG9cIikuY3NzKHsgZmlsdGVyOiAnYmx1cigxMHB4KScgfSk7XG4gIC8vXG4gICQuY3NzSG9va3MuZmlsdGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0uc3R5bGVbc3VwcG9ydC5maWx0ZXJdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihlbGVtLCB2YWx1ZSkge1xuICAgICAgZWxlbS5zdHlsZVtzdXBwb3J0LmZpbHRlcl0gPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8galF1ZXJ5IDEuOCsgc3VwcG9ydHMgcHJlZml4LWZyZWUgdHJhbnNpdGlvbnMsIHNvIHRoZXNlIHBvbHlmaWxscyB3aWxsIG5vdFxuICAvLyBiZSBuZWNlc3NhcnkuXG4gIGlmICgkLmZuLmpxdWVyeSA8IFwiMS44XCIpIHtcbiAgICAvLyAjIyAndHJhbnNmb3JtT3JpZ2luJyBDU1MgaG9va1xuICAgIC8vIEFsbG93cyB0aGUgdXNlIGZvciBgdHJhbnNmb3JtT3JpZ2luYCB0byBkZWZpbmUgd2hlcmUgc2NhbGluZyBhbmQgcm90YXRpb25cbiAgICAvLyBpcyBwaXZvdGVkLlxuICAgIC8vXG4gICAgLy8gICAgICQoXCIjaGVsbG9cIikuY3NzKHsgdHJhbnNmb3JtT3JpZ2luOiAnMCAwJyB9KTtcbiAgICAvL1xuICAgICQuY3NzSG9va3MudHJhbnNmb3JtT3JpZ2luID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLnN0eWxlW3N1cHBvcnQudHJhbnNmb3JtT3JpZ2luXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgIGVsZW0uc3R5bGVbc3VwcG9ydC50cmFuc2Zvcm1PcmlnaW5dID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vICMjICd0cmFuc2l0aW9uJyBDU1MgaG9va1xuICAgIC8vIEFsbG93cyB5b3UgdG8gdXNlIHRoZSBgdHJhbnNpdGlvbmAgcHJvcGVydHkgaW4gQ1NTLlxuICAgIC8vXG4gICAgLy8gICAgICQoXCIjaGVsbG9cIikuY3NzKHsgdHJhbnNpdGlvbjogJ2FsbCAwIGVhc2UgMCcgfSk7XG4gICAgLy9cbiAgICAkLmNzc0hvb2tzLnRyYW5zaXRpb24gPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uc3R5bGVbc3VwcG9ydC50cmFuc2l0aW9uXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgIGVsZW0uc3R5bGVbc3VwcG9ydC50cmFuc2l0aW9uXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyAjIyBPdGhlciBDU1MgaG9va3NcbiAgLy8gQWxsb3dzIHlvdSB0byByb3RhdGUsIHNjYWxlIGFuZCB0cmFuc2xhdGUuXG4gIHJlZ2lzdGVyQ3NzSG9vaygnc2NhbGUnKTtcbiAgcmVnaXN0ZXJDc3NIb29rKCdzY2FsZVgnKTtcbiAgcmVnaXN0ZXJDc3NIb29rKCdzY2FsZVknKTtcbiAgcmVnaXN0ZXJDc3NIb29rKCd0cmFuc2xhdGUnKTtcbiAgcmVnaXN0ZXJDc3NIb29rKCdyb3RhdGUnKTtcbiAgcmVnaXN0ZXJDc3NIb29rKCdyb3RhdGVYJyk7XG4gIHJlZ2lzdGVyQ3NzSG9vaygncm90YXRlWScpO1xuICByZWdpc3RlckNzc0hvb2soJ3JvdGF0ZTNkJyk7XG4gIHJlZ2lzdGVyQ3NzSG9vaygncGVyc3BlY3RpdmUnKTtcbiAgcmVnaXN0ZXJDc3NIb29rKCdza2V3WCcpO1xuICByZWdpc3RlckNzc0hvb2soJ3NrZXdZJyk7XG4gIHJlZ2lzdGVyQ3NzSG9vaygneCcsIHRydWUpO1xuICByZWdpc3RlckNzc0hvb2soJ3knLCB0cnVlKTtcblxuICAvLyAjIyBUcmFuc2Zvcm0gY2xhc3NcbiAgLy8gVGhpcyBpcyB0aGUgbWFpbiBjbGFzcyBvZiBhIHRyYW5zZm9ybWF0aW9uIHByb3BlcnR5IHRoYXQgcG93ZXJzXG4gIC8vIGAkLmZuLmNzcyh7IHRyYW5zZm9ybTogJy4uLicgfSlgLlxuICAvL1xuICAvLyBUaGlzIGlzLCBpbiBlc3NlbmNlLCBhIGRpY3Rpb25hcnkgb2JqZWN0IHdpdGgga2V5L3ZhbHVlcyBhcyBgLXRyYW5zZm9ybWBcbiAgLy8gcHJvcGVydGllcy5cbiAgLy9cbiAgLy8gICAgIHZhciB0ID0gbmV3IFRyYW5zZm9ybShcInJvdGF0ZSg5MCkgc2NhbGUoNClcIik7XG4gIC8vXG4gIC8vICAgICB0LnJvdGF0ZSAgICAgICAgICAgICAvLz0+IFwiOTBkZWdcIlxuICAvLyAgICAgdC5zY2FsZSAgICAgICAgICAgICAgLy89PiBcIjQsNFwiXG4gIC8vXG4gIC8vIFNldHRlcnMgYXJlIGFjY291bnRlZCBmb3IuXG4gIC8vXG4gIC8vICAgICB0LnNldCgncm90YXRlJywgNClcbiAgLy8gICAgIHQucm90YXRlICAgICAgICAgICAgIC8vPT4gXCI0ZGVnXCJcbiAgLy9cbiAgLy8gQ29udmVydCBpdCB0byBhIENTUyBzdHJpbmcgdXNpbmcgdGhlIGB0b1N0cmluZygpYCBhbmQgYHRvU3RyaW5nKHRydWUpYCAoZm9yIFdlYktpdClcbiAgLy8gZnVuY3Rpb25zLlxuICAvL1xuICAvLyAgICAgdC50b1N0cmluZygpICAgICAgICAgLy89PiBcInJvdGF0ZSg5MGRlZykgc2NhbGUoNCw0KVwiXG4gIC8vICAgICB0LnRvU3RyaW5nKHRydWUpICAgICAvLz0+IFwicm90YXRlKDkwZGVnKSBzY2FsZTNkKDQsNCwwKVwiIChXZWJLaXQgdmVyc2lvbilcbiAgLy9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykgeyB0aGlzLnBhcnNlKHN0cik7IH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgLy8gIyMjIHNldEZyb21TdHJpbmcoKVxuICAgIC8vIFNldHMgYSBwcm9wZXJ0eSBmcm9tIGEgc3RyaW5nLlxuICAgIC8vXG4gICAgLy8gICAgIHQuc2V0RnJvbVN0cmluZygnc2NhbGUnLCAnMiw0Jyk7XG4gICAgLy8gICAgIC8vIFNhbWUgYXMgc2V0KCdzY2FsZScsICcyJywgJzQnKTtcbiAgICAvL1xuICAgIHNldEZyb21TdHJpbmc6IGZ1bmN0aW9uKHByb3AsIHZhbCkge1xuICAgICAgdmFyIGFyZ3MgPVxuICAgICAgICAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpICA/IHZhbC5zcGxpdCgnLCcpIDpcbiAgICAgICAgKHZhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpID8gdmFsIDpcbiAgICAgICAgWyB2YWwgXTtcblxuICAgICAgYXJncy51bnNoaWZ0KHByb3ApO1xuXG4gICAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLnNldC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIHNldCgpXG4gICAgLy8gU2V0cyBhIHByb3BlcnR5LlxuICAgIC8vXG4gICAgLy8gICAgIHQuc2V0KCdzY2FsZScsIDIsIDQpO1xuICAgIC8vXG4gICAgc2V0OiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7XG4gICAgICBpZiAodGhpcy5zZXR0ZXJbcHJvcF0pIHtcbiAgICAgICAgdGhpcy5zZXR0ZXJbcHJvcF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BdID0gYXJncy5qb2luKCcsJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgaWYgKHRoaXMuZ2V0dGVyW3Byb3BdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldHRlcltwcm9wXS5hcHBseSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Byb3BdIHx8IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldHRlcjoge1xuICAgICAgLy8gIyMjIHJvdGF0ZVxuICAgICAgLy9cbiAgICAgIC8vICAgICAuY3NzKHsgcm90YXRlOiAzMCB9KVxuICAgICAgLy8gICAgIC5jc3MoeyByb3RhdGU6IFwiMzBcIiB9KVxuICAgICAgLy8gICAgIC5jc3MoeyByb3RhdGU6IFwiMzBkZWdcIiB9KVxuICAgICAgLy8gICAgIC5jc3MoeyByb3RhdGU6IFwiMzBkZWdcIiB9KVxuICAgICAgLy9cbiAgICAgIHJvdGF0ZTogZnVuY3Rpb24odGhldGEpIHtcbiAgICAgICAgdGhpcy5yb3RhdGUgPSB1bml0KHRoZXRhLCAnZGVnJyk7XG4gICAgICB9LFxuXG4gICAgICByb3RhdGVYOiBmdW5jdGlvbih0aGV0YSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVggPSB1bml0KHRoZXRhLCAnZGVnJyk7XG4gICAgICB9LFxuXG4gICAgICByb3RhdGVZOiBmdW5jdGlvbih0aGV0YSkge1xuICAgICAgICB0aGlzLnJvdGF0ZVkgPSB1bml0KHRoZXRhLCAnZGVnJyk7XG4gICAgICB9LFxuXG4gICAgICAvLyAjIyMgc2NhbGVcbiAgICAgIC8vXG4gICAgICAvLyAgICAgLmNzcyh7IHNjYWxlOiA5IH0pICAgICAgLy89PiBcInNjYWxlKDksOSlcIlxuICAgICAgLy8gICAgIC5jc3MoeyBzY2FsZTogJzMsMicgfSkgIC8vPT4gXCJzY2FsZSgzLDIpXCJcbiAgICAgIC8vXG4gICAgICBzY2FsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7IHkgPSB4OyB9XG4gICAgICAgIHRoaXMuc2NhbGUgPSB4ICsgXCIsXCIgKyB5O1xuICAgICAgfSxcblxuICAgICAgLy8gIyMjIHNrZXdYICsgc2tld1lcbiAgICAgIHNrZXdYOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuc2tld1ggPSB1bml0KHgsICdkZWcnKTtcbiAgICAgIH0sXG5cbiAgICAgIHNrZXdZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuc2tld1kgPSB1bml0KHksICdkZWcnKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vICMjIyBwZXJzcGVjdHZpZVxuICAgICAgcGVyc3BlY3RpdmU6IGZ1bmN0aW9uKGRpc3QpIHtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZSA9IHVuaXQoZGlzdCwgJ3B4Jyk7XG4gICAgICB9LFxuXG4gICAgICAvLyAjIyMgeCAvIHlcbiAgICAgIC8vIFRyYW5zbGF0aW9ucy4gTm90aWNlIGhvdyB0aGlzIGtlZXBzIHRoZSBvdGhlciB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgLmNzcyh7IHg6IDQgfSkgICAgICAgLy89PiBcInRyYW5zbGF0ZSg0cHgsIDApXCJcbiAgICAgIC8vICAgICAuY3NzKHsgeTogMTAgfSkgICAgICAvLz0+IFwidHJhbnNsYXRlKDRweCwgMTBweClcIlxuICAgICAgLy9cbiAgICAgIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5zZXQoJ3RyYW5zbGF0ZScsIHgsIG51bGwpO1xuICAgICAgfSxcblxuICAgICAgeTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnNldCgndHJhbnNsYXRlJywgbnVsbCwgeSk7XG4gICAgICB9LFxuXG4gICAgICAvLyAjIyMgdHJhbnNsYXRlXG4gICAgICAvLyBOb3RpY2UgaG93IHRoaXMga2VlcHMgdGhlIG90aGVyIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIC8vICAgICAuY3NzKHsgdHJhbnNsYXRlOiAnMiwgNScgfSkgICAgLy89PiBcInRyYW5zbGF0ZSgycHgsIDVweClcIlxuICAgICAgLy9cbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNsYXRlWCA9PT0gdW5kZWZpbmVkKSB7IHRoaXMuX3RyYW5zbGF0ZVggPSAwOyB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGVZID09PSB1bmRlZmluZWQpIHsgdGhpcy5fdHJhbnNsYXRlWSA9IDA7IH1cblxuICAgICAgICBpZiAoeCAhPT0gbnVsbCAmJiB4ICE9PSB1bmRlZmluZWQpIHsgdGhpcy5fdHJhbnNsYXRlWCA9IHVuaXQoeCwgJ3B4Jyk7IH1cbiAgICAgICAgaWYgKHkgIT09IG51bGwgJiYgeSAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuX3RyYW5zbGF0ZVkgPSB1bml0KHksICdweCcpOyB9XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUgPSB0aGlzLl90cmFuc2xhdGVYICsgXCIsXCIgKyB0aGlzLl90cmFuc2xhdGVZO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXR0ZXI6IHtcbiAgICAgIHg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNsYXRlWCB8fCAwO1xuICAgICAgfSxcblxuICAgICAgeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGVZIHx8IDA7XG4gICAgICB9LFxuXG4gICAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gKHRoaXMuc2NhbGUgfHwgXCIxLDFcIikuc3BsaXQoJywnKTtcbiAgICAgICAgaWYgKHNbMF0pIHsgc1swXSA9IHBhcnNlRmxvYXQoc1swXSk7IH1cbiAgICAgICAgaWYgKHNbMV0pIHsgc1sxXSA9IHBhcnNlRmxvYXQoc1sxXSk7IH1cblxuICAgICAgICAvLyBcIjIuNSwyLjVcIiA9PiAyLjVcbiAgICAgICAgLy8gXCIyLjUsMVwiID0+IFsyLjUsMV1cbiAgICAgICAgcmV0dXJuIChzWzBdID09PSBzWzFdKSA/IHNbMF0gOiBzO1xuICAgICAgfSxcblxuICAgICAgcm90YXRlM2Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcyA9ICh0aGlzLnJvdGF0ZTNkIHx8IFwiMCwwLDAsMGRlZ1wiKS5zcGxpdCgnLCcpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8PTM7ICsraSkge1xuICAgICAgICAgIGlmIChzW2ldKSB7IHNbaV0gPSBwYXJzZUZsb2F0KHNbaV0pOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNbM10pIHsgc1szXSA9IHVuaXQoc1szXSwgJ2RlZycpOyB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vICMjIyBwYXJzZSgpXG4gICAgLy8gUGFyc2VzIGZyb20gYSBzdHJpbmcuIENhbGxlZCBvbiBjb25zdHJ1Y3Rvci5cbiAgICBwYXJzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzdHIucmVwbGFjZSgvKFthLXpBLVowLTldKylcXCgoLio/KVxcKS9nLCBmdW5jdGlvbih4LCBwcm9wLCB2YWwpIHtcbiAgICAgICAgc2VsZi5zZXRGcm9tU3RyaW5nKHByb3AsIHZhbCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIHRvU3RyaW5nKClcbiAgICAvLyBDb252ZXJ0cyB0byBhIGB0cmFuc2l0aW9uYCBDU1MgcHJvcGVydHkgc3RyaW5nLiBJZiBgdXNlM2RgIGlzIGdpdmVuLFxuICAgIC8vIGl0IGNvbnZlcnRzIHRvIGEgYC13ZWJraXQtdHJhbnNpdGlvbmAgQ1NTIHByb3BlcnR5IHN0cmluZyBpbnN0ZWFkLlxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbih1c2UzZCkge1xuICAgICAgdmFyIHJlID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIC8vIERvbid0IHVzZSAzRCB0cmFuc2Zvcm1hdGlvbnMgaWYgdGhlIGJyb3dzZXIgY2FuJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgICBpZiAoKCFzdXBwb3J0LnRyYW5zZm9ybTNkKSAmJiAoXG4gICAgICAgICAgICAoaSA9PT0gJ3JvdGF0ZVgnKSB8fFxuICAgICAgICAgICAgKGkgPT09ICdyb3RhdGVZJykgfHxcbiAgICAgICAgICAgIChpID09PSAncGVyc3BlY3RpdmUnKSB8fFxuICAgICAgICAgICAgKGkgPT09ICd0cmFuc2Zvcm1PcmlnaW4nKSkpIHsgY29udGludWU7IH1cblxuICAgICAgICAgIGlmIChpWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIGlmICh1c2UzZCAmJiAoaSA9PT0gJ3NjYWxlJykpIHtcbiAgICAgICAgICAgICAgcmUucHVzaChpICsgXCIzZChcIiArIHRoaXNbaV0gKyBcIiwxKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlM2QgJiYgKGkgPT09ICd0cmFuc2xhdGUnKSkge1xuICAgICAgICAgICAgICByZS5wdXNoKGkgKyBcIjNkKFwiICsgdGhpc1tpXSArIFwiLDApXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmUucHVzaChpICsgXCIoXCIgKyB0aGlzW2ldICsgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmUuam9pbihcIiBcIik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNhbGxPclF1ZXVlKHNlbGYsIHF1ZXVlLCBmbikge1xuICAgIGlmIChxdWV1ZSA9PT0gdHJ1ZSkge1xuICAgICAgc2VsZi5xdWV1ZShmbik7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSkge1xuICAgICAgc2VsZi5xdWV1ZShxdWV1ZSwgZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgZ2V0UHJvcGVydGllcyhkaWN0KVxuICAvLyBSZXR1cm5zIHByb3BlcnRpZXMgKGZvciBgdHJhbnNpdGlvbi1wcm9wZXJ0eWApIGZvciBkaWN0aW9uYXJ5IGBwcm9wc2AuIFRoZVxuICAvLyB2YWx1ZSBvZiBgcHJvcHNgIGlzIHdoYXQgeW91IHdvdWxkIGV4cGVjdCBpbiBgJC5jc3MoLi4uKWAuXG4gIGZ1bmN0aW9uIGdldFByb3BlcnRpZXMocHJvcHMpIHtcbiAgICB2YXIgcmUgPSBbXTtcblxuICAgICQuZWFjaChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBrZXkgPSAkLmNhbWVsQ2FzZShrZXkpOyAvLyBDb252ZXJ0IFwidGV4dC1hbGlnblwiID0+IFwidGV4dEFsaWduXCJcbiAgICAgIGtleSA9ICQudHJhbnNpdC5wcm9wZXJ0eU1hcFtrZXldIHx8ICQuY3NzUHJvcHNba2V5XSB8fCBrZXk7XG4gICAgICBrZXkgPSB1bmNhbWVsKGtleSk7IC8vIENvbnZlcnQgYmFjayB0byBkYXNoZXJpemVkXG5cbiAgICAgIC8vIEdldCB2ZW5kb3Igc3BlY2lmeSBwcm9wZXJ0aWVcbiAgICAgIGlmIChzdXBwb3J0W2tleV0pXG4gICAgICAgIGtleSA9IHVuY2FtZWwoc3VwcG9ydFtrZXldKTtcblxuICAgICAgaWYgKCQuaW5BcnJheShrZXksIHJlKSA9PT0gLTEpIHsgcmUucHVzaChrZXkpOyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmU7XG4gIH1cblxuICAvLyAjIyMgZ2V0VHJhbnNpdGlvbigpXG4gIC8vIFJldHVybnMgdGhlIHRyYW5zaXRpb24gc3RyaW5nIHRvIGJlIHVzZWQgZm9yIHRoZSBgdHJhbnNpdGlvbmAgQ1NTIHByb3BlcnR5LlxuICAvL1xuICAvLyBFeGFtcGxlOlxuICAvL1xuICAvLyAgICAgZ2V0VHJhbnNpdGlvbih7IG9wYWNpdHk6IDEsIHJvdGF0ZTogMzAgfSwgNTAwLCAnZWFzZScpO1xuICAvLyAgICAgLy89PiAnb3BhY2l0eSA1MDBtcyBlYXNlLCAtd2Via2l0LXRyYW5zZm9ybSA1MDBtcyBlYXNlJ1xuICAvL1xuICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uKHByb3BlcnRpZXMsIGR1cmF0aW9uLCBlYXNpbmcsIGRlbGF5KSB7XG4gICAgLy8gR2V0IHRoZSBDU1MgcHJvcGVydGllcyBuZWVkZWQuXG4gICAgdmFyIHByb3BzID0gZ2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgIC8vIEFjY291bnQgZm9yIGFsaWFzZXMgKGBpbmAgPT4gYGVhc2UtaW5gKS5cbiAgICBpZiAoJC5jc3NFYXNlW2Vhc2luZ10pIHsgZWFzaW5nID0gJC5jc3NFYXNlW2Vhc2luZ107IH1cblxuICAgIC8vIEJ1aWxkIHRoZSBkdXJhdGlvbi9lYXNpbmcvZGVsYXkgYXR0cmlidXRlcyBmb3IgaXQuXG4gICAgdmFyIGF0dHJpYnMgPSAnJyArIHRvTVMoZHVyYXRpb24pICsgJyAnICsgZWFzaW5nO1xuICAgIGlmIChwYXJzZUludChkZWxheSwgMTApID4gMCkgeyBhdHRyaWJzICs9ICcgJyArIHRvTVMoZGVsYXkpOyB9XG5cbiAgICAvLyBGb3IgbW9yZSBwcm9wZXJ0aWVzLCBhZGQgdGhlbSB0aGlzIHdheTpcbiAgICAvLyBcIm1hcmdpbiAyMDBtcyBlYXNlLCBwYWRkaW5nIDIwMG1zIGVhc2UsIC4uLlwiXG4gICAgdmFyIHRyYW5zaXRpb25zID0gW107XG4gICAgJC5lYWNoKHByb3BzLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICB0cmFuc2l0aW9ucy5wdXNoKG5hbWUgKyAnICcgKyBhdHRyaWJzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2l0aW9ucy5qb2luKCcsICcpO1xuICB9XG5cbiAgLy8gIyMgJC5mbi50cmFuc2l0aW9uXG4gIC8vIFdvcmtzIGxpa2UgJC5mbi5hbmltYXRlKCksIGJ1dCB1c2VzIENTUyB0cmFuc2l0aW9ucy5cbiAgLy9cbiAgLy8gICAgICQoXCIuLi5cIikudHJhbnNpdGlvbih7IG9wYWNpdHk6IDAuMSwgc2NhbGU6IDAuMyB9KTtcbiAgLy9cbiAgLy8gICAgIC8vIFNwZWNpZmljIGR1cmF0aW9uXG4gIC8vICAgICAkKFwiLi4uXCIpLnRyYW5zaXRpb24oeyBvcGFjaXR5OiAwLjEsIHNjYWxlOiAwLjMgfSwgNTAwKTtcbiAgLy9cbiAgLy8gICAgIC8vIFdpdGggZHVyYXRpb24gYW5kIGVhc2luZ1xuICAvLyAgICAgJChcIi4uLlwiKS50cmFuc2l0aW9uKHsgb3BhY2l0eTogMC4xLCBzY2FsZTogMC4zIH0sIDUwMCwgJ2luJyk7XG4gIC8vXG4gIC8vICAgICAvLyBXaXRoIGNhbGxiYWNrXG4gIC8vICAgICAkKFwiLi4uXCIpLnRyYW5zaXRpb24oeyBvcGFjaXR5OiAwLjEsIHNjYWxlOiAwLjMgfSwgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgLy9cbiAgLy8gICAgIC8vIFdpdGggZXZlcnl0aGluZ1xuICAvLyAgICAgJChcIi4uLlwiKS50cmFuc2l0aW9uKHsgb3BhY2l0eTogMC4xLCBzY2FsZTogMC4zIH0sIDUwMCwgJ2luJywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgLy9cbiAgLy8gICAgIC8vIEFsdGVybmF0ZSBzeW50YXhcbiAgLy8gICAgICQoXCIuLi5cIikudHJhbnNpdGlvbih7XG4gIC8vICAgICAgIG9wYWNpdHk6IDAuMSxcbiAgLy8gICAgICAgZHVyYXRpb246IDIwMCxcbiAgLy8gICAgICAgZGVsYXk6IDQwLFxuICAvLyAgICAgICBlYXNpbmc6ICdpbicsXG4gIC8vICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHsgLyogLi4uICovIH1cbiAgLy8gICAgICB9KTtcbiAgLy9cbiAgJC5mbi50cmFuc2l0aW9uID0gJC5mbi50cmFuc2l0ID0gZnVuY3Rpb24ocHJvcGVydGllcywgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiAgPSB0aGlzO1xuICAgIHZhciBkZWxheSA9IDA7XG4gICAgdmFyIHF1ZXVlID0gdHJ1ZTtcblxuICAgIHZhciB0aGVzZVByb3BlcnRpZXMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcHJvcGVydGllcyk7XG5cbiAgICAvLyBBY2NvdW50IGZvciBgLnRyYW5zaXRpb24ocHJvcGVydGllcywgY2FsbGJhY2spYC5cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGR1cmF0aW9uO1xuICAgICAgZHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQWNjb3VudCBmb3IgYC50cmFuc2l0aW9uKHByb3BlcnRpZXMsIG9wdGlvbnMpYC5cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgZWFzaW5nID0gZHVyYXRpb24uZWFzaW5nO1xuICAgICAgZGVsYXkgPSBkdXJhdGlvbi5kZWxheSB8fCAwO1xuICAgICAgcXVldWUgPSB0eXBlb2YgZHVyYXRpb24ucXVldWUgPT09IFwidW5kZWZpbmVkXCIgPyB0cnVlIDogZHVyYXRpb24ucXVldWU7XG4gICAgICBjYWxsYmFjayA9IGR1cmF0aW9uLmNvbXBsZXRlO1xuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbi5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBBY2NvdW50IGZvciBgLnRyYW5zaXRpb24ocHJvcGVydGllcywgZHVyYXRpb24sIGNhbGxiYWNrKWAuXG4gICAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgZWFzaW5nID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEFsdGVybmF0ZSBzeW50YXguXG4gICAgaWYgKHR5cGVvZiB0aGVzZVByb3BlcnRpZXMuZWFzaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZWFzaW5nID0gdGhlc2VQcm9wZXJ0aWVzLmVhc2luZztcbiAgICAgIGRlbGV0ZSB0aGVzZVByb3BlcnRpZXMuZWFzaW5nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhlc2VQcm9wZXJ0aWVzLmR1cmF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZHVyYXRpb24gPSB0aGVzZVByb3BlcnRpZXMuZHVyYXRpb247XG4gICAgICBkZWxldGUgdGhlc2VQcm9wZXJ0aWVzLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhlc2VQcm9wZXJ0aWVzLmNvbXBsZXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FsbGJhY2sgPSB0aGVzZVByb3BlcnRpZXMuY29tcGxldGU7XG4gICAgICBkZWxldGUgdGhlc2VQcm9wZXJ0aWVzLmNvbXBsZXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhlc2VQcm9wZXJ0aWVzLnF1ZXVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVldWUgPSB0aGVzZVByb3BlcnRpZXMucXVldWU7XG4gICAgICBkZWxldGUgdGhlc2VQcm9wZXJ0aWVzLnF1ZXVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhlc2VQcm9wZXJ0aWVzLmRlbGF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsYXkgPSB0aGVzZVByb3BlcnRpZXMuZGVsYXk7XG4gICAgICBkZWxldGUgdGhlc2VQcm9wZXJ0aWVzLmRlbGF5O1xuICAgIH1cblxuICAgIC8vIFNldCBkZWZhdWx0cy4gKGA0MDBgIGR1cmF0aW9uLCBgZWFzZWAgZWFzaW5nKVxuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7IGR1cmF0aW9uID0gJC5meC5zcGVlZHMuX2RlZmF1bHQ7IH1cbiAgICBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ3VuZGVmaW5lZCcpICAgeyBlYXNpbmcgPSAkLmNzc0Vhc2UuX2RlZmF1bHQ7IH1cblxuICAgIGR1cmF0aW9uID0gdG9NUyhkdXJhdGlvbik7XG5cbiAgICAvLyBCdWlsZCB0aGUgYHRyYW5zaXRpb25gIHByb3BlcnR5LlxuICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSBnZXRUcmFuc2l0aW9uKHRoZXNlUHJvcGVydGllcywgZHVyYXRpb24sIGVhc2luZywgZGVsYXkpO1xuXG4gICAgLy8gQ29tcHV0ZSBkZWxheSB1bnRpbCBjYWxsYmFjay5cbiAgICAvLyBJZiB0aGlzIGJlY29tZXMgMCwgZG9uJ3QgYm90aGVyIHNldHRpbmcgdGhlIHRyYW5zaXRpb24gcHJvcGVydHkuXG4gICAgdmFyIHdvcmsgPSAkLnRyYW5zaXQuZW5hYmxlZCAmJiBzdXBwb3J0LnRyYW5zaXRpb247XG4gICAgdmFyIGkgPSB3b3JrID8gKHBhcnNlSW50KGR1cmF0aW9uLCAxMCkgKyBwYXJzZUludChkZWxheSwgMTApKSA6IDA7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgdG8gZG8uLi5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdmFyIGZuID0gZnVuY3Rpb24obmV4dCkge1xuICAgICAgICBzZWxmLmNzcyh0aGVzZVByb3BlcnRpZXMpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2suYXBwbHkoc2VsZik7IH1cbiAgICAgICAgaWYgKG5leHQpIHsgbmV4dCgpOyB9XG4gICAgICB9O1xuXG4gICAgICBjYWxsT3JRdWV1ZShzZWxmLCBxdWV1ZSwgZm4pO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGUgb2xkIHRyYW5zaXRpb25zIG9mIGVhY2ggZWxlbWVudCBzbyB3ZSBjYW4gcmVzdG9yZSBpdCBsYXRlci5cbiAgICB2YXIgb2xkVHJhbnNpdGlvbnMgPSB7fTtcblxuICAgIHZhciBydW4gPSBmdW5jdGlvbihuZXh0Q2FsbCkge1xuICAgICAgdmFyIGJvdW5kID0gZmFsc2U7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIGNhbGxiYWNrLlxuICAgICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChib3VuZCkgeyBzZWxmLnVuYmluZCh0cmFuc2l0aW9uRW5kLCBjYik7IH1cblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBzZWxmLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlW3N1cHBvcnQudHJhbnNpdGlvbl0gPSAob2xkVHJhbnNpdGlvbnNbdGhpc10gfHwgbnVsbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7IGNhbGxiYWNrLmFwcGx5KHNlbGYpOyB9XG4gICAgICAgIGlmICh0eXBlb2YgbmV4dENhbGwgPT09ICdmdW5jdGlvbicpIHsgbmV4dENhbGwoKTsgfVxuICAgICAgfTtcblxuICAgICAgaWYgKChpID4gMCkgJiYgKHRyYW5zaXRpb25FbmQpICYmICgkLnRyYW5zaXQudXNlVHJhbnNpdGlvbkVuZCkpIHtcbiAgICAgICAgLy8gVXNlIHRoZSAndHJhbnNpdGlvbmVuZCcgZXZlbnQgaWYgaXQncyBhdmFpbGFibGUuXG4gICAgICAgIGJvdW5kID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5iaW5kKHRyYW5zaXRpb25FbmQsIGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHRpbWVycyBpZiB0aGUgJ3RyYW5zaXRpb25lbmQnIGV2ZW50IGlzbid0IHN1cHBvcnRlZC5cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2IsIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSB0cmFuc2l0aW9ucy5cbiAgICAgIHNlbGYuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZVtzdXBwb3J0LnRyYW5zaXRpb25dID0gdHJhbnNpdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcykuY3NzKHRoZXNlUHJvcGVydGllcyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRGVmZXIgcnVubmluZy4gVGhpcyBhbGxvd3MgdGhlIGJyb3dzZXIgdG8gcGFpbnQgYW55IHBlbmRpbmcgQ1NTIGl0IGhhc24ndFxuICAgIC8vIHBhaW50ZWQgeWV0IGJlZm9yZSBkb2luZyB0aGUgdHJhbnNpdGlvbnMuXG4gICAgdmFyIGRlZmVycmVkUnVuID0gZnVuY3Rpb24obmV4dCkge1xuICAgICAgICB0aGlzLm9mZnNldFdpZHRoOyAvLyBmb3JjZSBhIHJlcGFpbnRcbiAgICAgICAgcnVuKG5leHQpO1xuICAgIH07XG5cbiAgICAvLyBVc2UgalF1ZXJ5J3MgZnggcXVldWUuXG4gICAgY2FsbE9yUXVldWUoc2VsZiwgcXVldWUsIGRlZmVycmVkUnVuKTtcblxuICAgIC8vIENoYWluYWJpbGl0eS5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiByZWdpc3RlckNzc0hvb2socHJvcCwgaXNQaXhlbHMpIHtcbiAgICAvLyBGb3IgY2VydGFpbiBwcm9wZXJ0aWVzLCB0aGUgJ3B4JyBzaG91bGQgbm90IGJlIGltcGxpZWQuXG4gICAgaWYgKCFpc1BpeGVscykgeyAkLmNzc051bWJlcltwcm9wXSA9IHRydWU7IH1cblxuICAgICQudHJhbnNpdC5wcm9wZXJ0eU1hcFtwcm9wXSA9IHN1cHBvcnQudHJhbnNmb3JtO1xuXG4gICAgJC5jc3NIb29rc1twcm9wXSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICB2YXIgdCA9ICQoZWxlbSkuY3NzKCd0cmFuc2l0OnRyYW5zZm9ybScpO1xuICAgICAgICByZXR1cm4gdC5nZXQocHJvcCk7XG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgIHZhciB0ID0gJChlbGVtKS5jc3MoJ3RyYW5zaXQ6dHJhbnNmb3JtJyk7XG4gICAgICAgIHQuc2V0RnJvbVN0cmluZyhwcm9wLCB2YWx1ZSk7XG5cbiAgICAgICAgJChlbGVtKS5jc3MoeyAndHJhbnNpdDp0cmFuc2Zvcm0nOiB0IH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgfVxuXG4gIC8vICMjIyB1bmNhbWVsKHN0cilcbiAgLy8gQ29udmVydHMgYSBjYW1lbGNhc2Ugc3RyaW5nIHRvIGEgZGFzaGVyaXplZCBzdHJpbmcuXG4gIC8vIChgbWFyZ2luTGVmdGAgPT4gYG1hcmdpbi1sZWZ0YClcbiAgZnVuY3Rpb24gdW5jYW1lbChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24obGV0dGVyKSB7IHJldHVybiAnLScgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKTsgfSk7XG4gIH1cblxuICAvLyAjIyMgdW5pdChudW1iZXIsIHVuaXQpXG4gIC8vIEVuc3VyZXMgdGhhdCBudW1iZXIgYG51bWJlcmAgaGFzIGEgdW5pdC4gSWYgbm8gdW5pdCBpcyBmb3VuZCwgYXNzdW1lIHRoZVxuICAvLyBkZWZhdWx0IGlzIGB1bml0YC5cbiAgLy9cbiAgLy8gICAgIHVuaXQoMiwgJ3B4JykgICAgICAgICAgLy89PiBcIjJweFwiXG4gIC8vICAgICB1bml0KFwiMzBkZWdcIiwgJ3JhZCcpICAgLy89PiBcIjMwZGVnXCJcbiAgLy9cbiAgZnVuY3Rpb24gdW5pdChpLCB1bml0cykge1xuICAgIGlmICgodHlwZW9mIGkgPT09IFwic3RyaW5nXCIpICYmICghaS5tYXRjaCgvXltcXC0wLTlcXC5dKyQvKSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJcIiArIGkgKyB1bml0cztcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgdG9NUyhkdXJhdGlvbilcbiAgLy8gQ29udmVydHMgZ2l2ZW4gYGR1cmF0aW9uYCB0byBhIG1pbGxpc2Vjb25kIHN0cmluZy5cbiAgLy9cbiAgLy8gdG9NUygnZmFzdCcpID0+ICQuZnguc3BlZWRzW2ldID0+IFwiMjAwbXNcIlxuICAvLyB0b01TKCdub3JtYWwnKSAvLz0+ICQuZnguc3BlZWRzLl9kZWZhdWx0ID0+IFwiNDAwbXNcIlxuICAvLyB0b01TKDEwKSAvLz0+ICcxMG1zJ1xuICAvLyB0b01TKCcxMDBtcycpIC8vPT4gJzEwMG1zJyAgXG4gIC8vXG4gIGZ1bmN0aW9uIHRvTVMoZHVyYXRpb24pIHtcbiAgICB2YXIgaSA9IGR1cmF0aW9uO1xuXG4gICAgLy8gQWxsb3cgc3RyaW5nIGR1cmF0aW9ucyBsaWtlICdmYXN0JyBhbmQgJ3Nsb3cnLCB3aXRob3V0IG92ZXJyaWRpbmcgbnVtZXJpYyB2YWx1ZXMuXG4gICAgaWYgKHR5cGVvZiBpID09PSAnc3RyaW5nJyAmJiAoIWkubWF0Y2goL15bXFwtMC05XFwuXSsvKSkpIHsgaSA9ICQuZnguc3BlZWRzW2ldIHx8ICQuZnguc3BlZWRzLl9kZWZhdWx0OyB9XG5cbiAgICByZXR1cm4gdW5pdChpLCAnbXMnKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBzb21lIGZ1bmN0aW9ucyBmb3IgdGVzdGFibGUtbmVzcy5cbiAgJC50cmFuc2l0LmdldFRyYW5zaXRpb25WYWx1ZSA9IGdldFRyYW5zaXRpb247XG5cbiAgcmV0dXJuICQ7XG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jquery.transit/jquery.transit.js\n");

/***/ }),

/***/ "./node_modules/pxloader/PxLoader.js":
/*!*******************************************!*\
  !*** ./node_modules/pxloader/PxLoader.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * PixelLab Resource Loader\n * Loads resources while providing progress updates.\n */\n(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return (root.PxLoader = factory());\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    function PxLoader(settings) {\n\n        // merge settings with defaults\n        settings = settings || {};\n        this.settings = settings;\n\n        // how frequently we poll resources for progress\n        if (settings.statusInterval == null) {\n            settings.statusInterval = 5000; // every 5 seconds by default\n        }\n\n        // delay before logging since last progress change\n        if (settings.loggingDelay == null) {\n            settings.loggingDelay = 20 * 1000; // log stragglers after 20 secs\n        }\n\n        // stop waiting if no progress has been made in the moving time window\n        if (settings.noProgressTimeout == null) {\n            settings.noProgressTimeout = Infinity; // do not stop waiting by default\n        }\n\n        var entries = [],\n            // holds resources to be loaded with their status\n            completionListeners = [],\n            progressListeners = [],\n            timeStarted, progressChanged = Date.now();\n\n        /**\n         * The status of a resource\n         * @enum {number}\n         */\n        var ResourceState = {\n            QUEUED: 0,\n            WAITING: 1,\n            LOADED: 2,\n            ERROR: 3,\n            TIMEOUT: 4\n        };\n\n        // places non-array values into an array.\n        var ensureArray = function(val) {\n            if (val == null) {\n                return [];\n            }\n\n            if (Array.isArray(val)) {\n                return val;\n            }\n\n            return [val];\n        };\n\n        // add an entry to the list of resources to be loaded\n        this.add = function(resource) {\n\n            // TODO: would be better to create a base class for all resources and\n            // initialize the PxLoaderTags there rather than overwritting tags here\n            resource.tags = new PxLoaderTags(resource.tags);\n\n            // ensure priority is set\n            if (resource.priority == null) {\n                resource.priority = Infinity;\n            }\n\n            entries.push({\n                resource: resource,\n                status: ResourceState.QUEUED\n            });\n        };\n\n        this.addProgressListener = function(callback, tags) {\n            progressListeners.push({\n                callback: callback,\n                tags: new PxLoaderTags(tags)\n            });\n        };\n\n        this.addCompletionListener = function(callback, tags) {\n            completionListeners.push({\n                tags: new PxLoaderTags(tags),\n                callback: function(e) {\n                    if (e.completedCount === e.totalCount) {\n                        callback(e);\n                    }\n                }\n            });\n        };\n\n        // creates a comparison function for resources\n        var getResourceSort = function(orderedTags) {\n\n            // helper to get the top tag's order for a resource\n            orderedTags = ensureArray(orderedTags);\n            var getTagOrder = function(entry) {\n                var resource = entry.resource,\n                    bestIndex = Infinity;\n                for (var i = 0; i < resource.tags.length; i++) {\n                    for (var j = 0; j < Math.min(orderedTags.length, bestIndex); j++) {\n                        if (resource.tags.all[i] === orderedTags[j] && j < bestIndex) {\n                            bestIndex = j;\n                            if (bestIndex === 0) {\n                                break;\n                            }\n                        }\n                        if (bestIndex === 0) {\n                            break;\n                        }\n                    }\n                }\n                return bestIndex;\n            };\n            return function(a, b) {\n                // check tag order first\n                var aOrder = getTagOrder(a),\n                    bOrder = getTagOrder(b);\n                if (aOrder < bOrder) { return -1; }\n                if (aOrder > bOrder) { return 1; }\n\n                // now check priority\n                if (a.priority < b.priority) { return -1; }\n                if (a.priority > b.priority) { return 1; }\n                return 0;\n            };\n        };\n\n        this.start = function(orderedTags) {\n            timeStarted = Date.now();\n\n            // first order the resources\n            var compareResources = getResourceSort(orderedTags);\n            entries.sort(compareResources);\n\n            // trigger requests for each resource\n            for (var i = 0, len = entries.length; i < len; i++) {\n                var entry = entries[i];\n                entry.status = ResourceState.WAITING;\n                entry.resource.start(this);\n            }\n\n            // do an initial status check soon since items may be loaded from the cache\n            setTimeout(statusCheck, 100);\n        };\n\n        var statusCheck = function() {\n            var checkAgain = false,\n                noProgressTime = Date.now() - progressChanged,\n                timedOut = (noProgressTime >= settings.noProgressTimeout),\n                shouldLog = (noProgressTime >= settings.loggingDelay);\n\n            for (var i = 0, len = entries.length; i < len; i++) {\n                var entry = entries[i];\n                if (entry.status !== ResourceState.WAITING) {\n                    continue;\n                }\n\n                // see if the resource has loaded\n                if (entry.resource.checkStatus) {\n                    entry.resource.checkStatus();\n                }\n\n                // if still waiting, mark as timed out or make sure we check again\n                if (entry.status === ResourceState.WAITING) {\n                    if (timedOut) {\n                        entry.resource.onTimeout();\n                    } else {\n                        checkAgain = true;\n                    }\n                }\n            }\n\n            // log any resources that are still pending\n            if (shouldLog && checkAgain) {\n                log();\n            }\n\n            if (checkAgain) {\n                setTimeout(statusCheck, settings.statusInterval);\n            }\n        };\n\n        this.isBusy = function() {\n            for (var i = 0, len = entries.length; i < len; i++) {\n                if (entries[i].status === ResourceState.QUEUED || entries[i].status === ResourceState.WAITING) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        var onProgress = function(resource, statusType) {\n\n            var entry = null,\n                i, len, listeners, listener, shouldCall;\n\n            // find the entry for the resource\n            for (i = 0, len = entries.length; i < len; i++) {\n                if (entries[i].resource === resource) {\n                    entry = entries[i];\n                    break;\n                }\n            }\n\n            // we have already updated the status of the resource\n            if (entry == null || entry.status !== ResourceState.WAITING) {\n                return;\n            }\n            entry.status = statusType;\n            progressChanged = Date.now();\n\n            // ensure completion listeners fire after progress listeners\n            listeners = progressListeners.concat( completionListeners );\n\n            // fire callbacks for interested listeners\n            for (i = 0, len = listeners.length; i < len; i++) {\n\n                listener = listeners[i];\n                if (listener.tags.length === 0) {\n                    // no tags specified so always tell the listener\n                    shouldCall = true;\n                } else {\n                    // listener only wants to hear about certain tags\n                    shouldCall = resource.tags.intersects(listener.tags);\n                }\n\n                if (shouldCall) {\n                    sendProgress(entry, listener);\n                }\n            }\n        };\n\n        this.onLoad = function(resource) {\n            onProgress(resource, ResourceState.LOADED);\n        };\n        this.onError = function(resource) {\n            onProgress(resource, ResourceState.ERROR);\n        };\n        this.onTimeout = function(resource) {\n            onProgress(resource, ResourceState.TIMEOUT);\n        };\n\n        // sends a progress report to a listener\n        var sendProgress = function(updatedEntry, listener) {\n            // find stats for all the resources the caller is interested in\n            var completed = 0,\n                total = 0,\n                i, len, entry, includeResource;\n            for (i = 0, len = entries.length; i < len; i++) {\n\n                entry = entries[i];\n                includeResource = false;\n\n                if (listener.tags.length === 0) {\n                    // no tags specified so always tell the listener\n                    includeResource = true;\n                } else {\n                    includeResource = entry.resource.tags.intersects(listener.tags);\n                }\n\n                if (includeResource) {\n                    total++;\n                    if (entry.status === ResourceState.LOADED ||\n                        entry.status === ResourceState.ERROR ||\n                        entry.status === ResourceState.TIMEOUT) {\n\n                        completed++;\n                    }\n                }\n            }\n\n            listener.callback({\n                // info about the resource that changed\n                resource: updatedEntry.resource,\n\n                // should we expose StatusType instead?\n                loaded: (updatedEntry.status === ResourceState.LOADED),\n                error: (updatedEntry.status === ResourceState.ERROR),\n                timeout: (updatedEntry.status === ResourceState.TIMEOUT),\n\n                // updated stats for all resources\n                completedCount: completed,\n                totalCount: total\n            });\n        };\n\n        // prints the status of each resource to the console\n        var log = this.log = function(showAll) {\n            if (!window.console) {\n                return;\n            }\n\n            var elapsedSeconds = Math.round((Date.now() - timeStarted) / 1000);\n            window.console.log('PxLoader elapsed: ' + elapsedSeconds + ' sec');\n\n            for (var i = 0, len = entries.length; i < len; i++) {\n                var entry = entries[i];\n                if (!showAll && entry.status !== ResourceState.WAITING) {\n                    continue;\n                }\n\n                var message = 'PxLoader: #' + i + ' ' + entry.resource.getName();\n                switch(entry.status) {\n                    case ResourceState.QUEUED:\n                        message += ' (Not Started)';\n                        break;\n                    case ResourceState.WAITING:\n                        message += ' (Waiting)';\n                        break;\n                    case ResourceState.LOADED:\n                        message += ' (Loaded)';\n                        break;\n                    case ResourceState.ERROR:\n                        message += ' (Error)';\n                        break;\n                    case ResourceState.TIMEOUT:\n                        message += ' (Timeout)';\n                        break;\n                }\n\n                if (entry.resource.tags.length > 0) {\n                    message += ' Tags: [' + entry.resource.tags.all.join(',') + ']';\n                }\n\n                window.console.log(message);\n            }\n        };\n    }\n\n\n    // Tag object to handle tag intersection; once created not meant to be changed\n    // Performance rationale: http://jsperf.com/lists-indexof-vs-in-operator/3\n\n    function PxLoaderTags(values) {\n\n        this.all = [];\n        this.first = null; // cache the first value\n        this.length = 0;\n\n        // holds values as keys for quick lookup\n        this.lookup = {};\n\n        if (values) {\n\n            // first fill the array of all values\n            if (Array.isArray(values)) {\n                // copy the array of values, just to be safe\n                this.all = values.slice(0);\n            } else if (typeof values === 'object') {\n                for (var key in values) {\n                    if(values.hasOwnProperty(key)) {\n                        this.all.push(key);\n                    }\n                }\n            } else {\n                this.all.push(values);\n            }\n\n            // cache the length and the first value\n            this.length = this.all.length;\n            if (this.length > 0) {\n                this.first = this.all[0];\n            }\n\n            // set values as object keys for quick lookup during intersection test\n            for (var i = 0; i < this.length; i++) {\n                this.lookup[this.all[i]] = true;\n            }\n        }\n    }\n\n    // compare this object with another; return true if they share at least one value\n    PxLoaderTags.prototype.intersects = function(other) {\n\n        // handle empty values case\n        if (this.length === 0 || other.length === 0) {\n            return false;\n        }\n\n        // only a single value to compare?\n        if (this.length === 1 && other.length === 1) {\n            return this.first === other.first;\n        }\n\n        // better to loop through the smaller object\n        if (other.length < this.length) {\n            return other.intersects(this);\n        }\n\n        // loop through every key to see if there are any matches\n        for (var key in this.lookup) {\n            if (other.lookup[key]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    return PxLoader;\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHhsb2FkZXIvUHhMb2FkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHhsb2FkZXIvUHhMb2FkZXIuanM/NTBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogUGl4ZWxMYWIgUmVzb3VyY2UgTG9hZGVyXG4gKiBMb2FkcyByZXNvdXJjZXMgd2hpbGUgcHJvdmlkaW5nIHByb2dyZXNzIHVwZGF0ZXMuXG4gKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAocm9vdC5QeExvYWRlciA9IGZhY3RvcnkoKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICByb290LlB4TG9hZGVyID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB4TG9hZGVyKHNldHRpbmdzKSB7XG5cbiAgICAgICAgLy8gbWVyZ2Ugc2V0dGluZ3Mgd2l0aCBkZWZhdWx0c1xuICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICAgICAgLy8gaG93IGZyZXF1ZW50bHkgd2UgcG9sbCByZXNvdXJjZXMgZm9yIHByb2dyZXNzXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdGF0dXNJbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zdGF0dXNJbnRlcnZhbCA9IDUwMDA7IC8vIGV2ZXJ5IDUgc2Vjb25kcyBieSBkZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxheSBiZWZvcmUgbG9nZ2luZyBzaW5jZSBsYXN0IHByb2dyZXNzIGNoYW5nZVxuICAgICAgICBpZiAoc2V0dGluZ3MubG9nZ2luZ0RlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmxvZ2dpbmdEZWxheSA9IDIwICogMTAwMDsgLy8gbG9nIHN0cmFnZ2xlcnMgYWZ0ZXIgMjAgc2Vjc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcCB3YWl0aW5nIGlmIG5vIHByb2dyZXNzIGhhcyBiZWVuIG1hZGUgaW4gdGhlIG1vdmluZyB0aW1lIHdpbmRvd1xuICAgICAgICBpZiAoc2V0dGluZ3Mubm9Qcm9ncmVzc1RpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0dGluZ3Mubm9Qcm9ncmVzc1RpbWVvdXQgPSBJbmZpbml0eTsgLy8gZG8gbm90IHN0b3Agd2FpdGluZyBieSBkZWZhdWx0XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW50cmllcyA9IFtdLFxuICAgICAgICAgICAgLy8gaG9sZHMgcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCB3aXRoIHRoZWlyIHN0YXR1c1xuICAgICAgICAgICAgY29tcGxldGlvbkxpc3RlbmVycyA9IFtdLFxuICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgICAgIHRpbWVTdGFydGVkLCBwcm9ncmVzc0NoYW5nZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3RhdHVzIG9mIGEgcmVzb3VyY2VcbiAgICAgICAgICogQGVudW0ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBSZXNvdXJjZVN0YXRlID0ge1xuICAgICAgICAgICAgUVVFVUVEOiAwLFxuICAgICAgICAgICAgV0FJVElORzogMSxcbiAgICAgICAgICAgIExPQURFRDogMixcbiAgICAgICAgICAgIEVSUk9SOiAzLFxuICAgICAgICAgICAgVElNRU9VVDogNFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBsYWNlcyBub24tYXJyYXkgdmFsdWVzIGludG8gYW4gYXJyYXkuXG4gICAgICAgIHZhciBlbnN1cmVBcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt2YWxdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBhbiBlbnRyeSB0byB0aGUgbGlzdCBvZiByZXNvdXJjZXMgdG8gYmUgbG9hZGVkXG4gICAgICAgIHRoaXMuYWRkID0gZnVuY3Rpb24ocmVzb3VyY2UpIHtcblxuICAgICAgICAgICAgLy8gVE9ETzogd291bGQgYmUgYmV0dGVyIHRvIGNyZWF0ZSBhIGJhc2UgY2xhc3MgZm9yIGFsbCByZXNvdXJjZXMgYW5kXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBQeExvYWRlclRhZ3MgdGhlcmUgcmF0aGVyIHRoYW4gb3ZlcndyaXR0aW5nIHRhZ3MgaGVyZVxuICAgICAgICAgICAgcmVzb3VyY2UudGFncyA9IG5ldyBQeExvYWRlclRhZ3MocmVzb3VyY2UudGFncyk7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBwcmlvcml0eSBpcyBzZXRcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5wcmlvcml0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UucHJpb3JpdHkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogcmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBSZXNvdXJjZVN0YXRlLlFVRVVFRFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGRQcm9ncmVzc0xpc3RlbmVyID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRhZ3MpIHtcbiAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICB0YWdzOiBuZXcgUHhMb2FkZXJUYWdzKHRhZ3MpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZENvbXBsZXRpb25MaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0YWdzKSB7XG4gICAgICAgICAgICBjb21wbGV0aW9uTGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhZ3M6IG5ldyBQeExvYWRlclRhZ3ModGFncyksXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29tcGxldGVkQ291bnQgPT09IGUudG90YWxDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjcmVhdGVzIGEgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgcmVzb3VyY2VzXG4gICAgICAgIHZhciBnZXRSZXNvdXJjZVNvcnQgPSBmdW5jdGlvbihvcmRlcmVkVGFncykge1xuXG4gICAgICAgICAgICAvLyBoZWxwZXIgdG8gZ2V0IHRoZSB0b3AgdGFnJ3Mgb3JkZXIgZm9yIGEgcmVzb3VyY2VcbiAgICAgICAgICAgIG9yZGVyZWRUYWdzID0gZW5zdXJlQXJyYXkob3JkZXJlZFRhZ3MpO1xuICAgICAgICAgICAgdmFyIGdldFRhZ09yZGVyID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBlbnRyeS5yZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgYmVzdEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvdXJjZS50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTWF0aC5taW4ob3JkZXJlZFRhZ3MubGVuZ3RoLCBiZXN0SW5kZXgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZS50YWdzLmFsbFtpXSA9PT0gb3JkZXJlZFRhZ3Nbal0gJiYgaiA8IGJlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RJbmRleDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRhZyBvcmRlciBmaXJzdFxuICAgICAgICAgICAgICAgIHZhciBhT3JkZXIgPSBnZXRUYWdPcmRlcihhKSxcbiAgICAgICAgICAgICAgICAgICAgYk9yZGVyID0gZ2V0VGFnT3JkZXIoYik7XG4gICAgICAgICAgICAgICAgaWYgKGFPcmRlciA8IGJPcmRlcikgeyByZXR1cm4gLTE7IH1cbiAgICAgICAgICAgICAgICBpZiAoYU9yZGVyID4gYk9yZGVyKSB7IHJldHVybiAxOyB9XG5cbiAgICAgICAgICAgICAgICAvLyBub3cgY2hlY2sgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICBpZiAoYS5wcmlvcml0eSA8IGIucHJpb3JpdHkpIHsgcmV0dXJuIC0xOyB9XG4gICAgICAgICAgICAgICAgaWYgKGEucHJpb3JpdHkgPiBiLnByaW9yaXR5KSB7IHJldHVybiAxOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbihvcmRlcmVkVGFncykge1xuICAgICAgICAgICAgdGltZVN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICAvLyBmaXJzdCBvcmRlciB0aGUgcmVzb3VyY2VzXG4gICAgICAgICAgICB2YXIgY29tcGFyZVJlc291cmNlcyA9IGdldFJlc291cmNlU29ydChvcmRlcmVkVGFncyk7XG4gICAgICAgICAgICBlbnRyaWVzLnNvcnQoY29tcGFyZVJlc291cmNlcyk7XG5cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgcmVxdWVzdHMgZm9yIGVhY2ggcmVzb3VyY2VcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGF0dXMgPSBSZXNvdXJjZVN0YXRlLldBSVRJTkc7XG4gICAgICAgICAgICAgICAgZW50cnkucmVzb3VyY2Uuc3RhcnQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIGFuIGluaXRpYWwgc3RhdHVzIGNoZWNrIHNvb24gc2luY2UgaXRlbXMgbWF5IGJlIGxvYWRlZCBmcm9tIHRoZSBjYWNoZVxuICAgICAgICAgICAgc2V0VGltZW91dChzdGF0dXNDaGVjaywgMTAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RhdHVzQ2hlY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGVja0FnYWluID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbm9Qcm9ncmVzc1RpbWUgPSBEYXRlLm5vdygpIC0gcHJvZ3Jlc3NDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIHRpbWVkT3V0ID0gKG5vUHJvZ3Jlc3NUaW1lID49IHNldHRpbmdzLm5vUHJvZ3Jlc3NUaW1lb3V0KSxcbiAgICAgICAgICAgICAgICBzaG91bGRMb2cgPSAobm9Qcm9ncmVzc1RpbWUgPj0gc2V0dGluZ3MubG9nZ2luZ0RlbGF5KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5zdGF0dXMgIT09IFJlc291cmNlU3RhdGUuV0FJVElORykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWUgaWYgdGhlIHJlc291cmNlIGhhcyBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVzb3VyY2UuY2hlY2tTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucmVzb3VyY2UuY2hlY2tTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBzdGlsbCB3YWl0aW5nLCBtYXJrIGFzIHRpbWVkIG91dCBvciBtYWtlIHN1cmUgd2UgY2hlY2sgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhdHVzID09PSBSZXNvdXJjZVN0YXRlLldBSVRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXNvdXJjZS5vblRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb2cgYW55IHJlc291cmNlcyB0aGF0IGFyZSBzdGlsbCBwZW5kaW5nXG4gICAgICAgICAgICBpZiAoc2hvdWxkTG9nICYmIGNoZWNrQWdhaW4pIHtcbiAgICAgICAgICAgICAgICBsb2coKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoZWNrQWdhaW4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHN0YXR1c0NoZWNrLCBzZXR0aW5ncy5zdGF0dXNJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pc0J1c3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXNbaV0uc3RhdHVzID09PSBSZXNvdXJjZVN0YXRlLlFVRVVFRCB8fCBlbnRyaWVzW2ldLnN0YXR1cyA9PT0gUmVzb3VyY2VTdGF0ZS5XQUlUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb25Qcm9ncmVzcyA9IGZ1bmN0aW9uKHJlc291cmNlLCBzdGF0dXNUeXBlKSB7XG5cbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSwgbGVuLCBsaXN0ZW5lcnMsIGxpc3RlbmVyLCBzaG91bGRDYWxsO1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBlbnRyeSBmb3IgdGhlIHJlc291cmNlXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXNbaV0ucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGFscmVhZHkgdXBkYXRlZCB0aGUgc3RhdHVzIG9mIHRoZSByZXNvdXJjZVxuICAgICAgICAgICAgaWYgKGVudHJ5ID09IG51bGwgfHwgZW50cnkuc3RhdHVzICE9PSBSZXNvdXJjZVN0YXRlLldBSVRJTkcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeS5zdGF0dXMgPSBzdGF0dXNUeXBlO1xuICAgICAgICAgICAgcHJvZ3Jlc3NDaGFuZ2VkID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgLy8gZW5zdXJlIGNvbXBsZXRpb24gbGlzdGVuZXJzIGZpcmUgYWZ0ZXIgcHJvZ3Jlc3MgbGlzdGVuZXJzXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBwcm9ncmVzc0xpc3RlbmVycy5jb25jYXQoIGNvbXBsZXRpb25MaXN0ZW5lcnMgKTtcblxuICAgICAgICAgICAgLy8gZmlyZSBjYWxsYmFja3MgZm9yIGludGVyZXN0ZWQgbGlzdGVuZXJzXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci50YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyB0YWdzIHNwZWNpZmllZCBzbyBhbHdheXMgdGVsbCB0aGUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuZXIgb25seSB3YW50cyB0byBoZWFyIGFib3V0IGNlcnRhaW4gdGFnc1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRDYWxsID0gcmVzb3VyY2UudGFncy5pbnRlcnNlY3RzKGxpc3RlbmVyLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRQcm9ncmVzcyhlbnRyeSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uTG9hZCA9IGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHJlc291cmNlLCBSZXNvdXJjZVN0YXRlLkxPQURFRCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25FcnJvciA9IGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHJlc291cmNlLCBSZXNvdXJjZVN0YXRlLkVSUk9SKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblRpbWVvdXQgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhyZXNvdXJjZSwgUmVzb3VyY2VTdGF0ZS5USU1FT1VUKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZW5kcyBhIHByb2dyZXNzIHJlcG9ydCB0byBhIGxpc3RlbmVyXG4gICAgICAgIHZhciBzZW5kUHJvZ3Jlc3MgPSBmdW5jdGlvbih1cGRhdGVkRW50cnksIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAvLyBmaW5kIHN0YXRzIGZvciBhbGwgdGhlIHJlc291cmNlcyB0aGUgY2FsbGVyIGlzIGludGVyZXN0ZWQgaW5cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwLFxuICAgICAgICAgICAgICAgIHRvdGFsID0gMCxcbiAgICAgICAgICAgICAgICBpLCBsZW4sIGVudHJ5LCBpbmNsdWRlUmVzb3VyY2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBlbnRyeSA9IGVudHJpZXNbaV07XG4gICAgICAgICAgICAgICAgaW5jbHVkZVJlc291cmNlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gdGFncyBzcGVjaWZpZWQgc28gYWx3YXlzIHRlbGwgdGhlIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSZXNvdXJjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVJlc291cmNlID0gZW50cnkucmVzb3VyY2UudGFncy5pbnRlcnNlY3RzKGxpc3RlbmVyLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlUmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXR1cyA9PT0gUmVzb3VyY2VTdGF0ZS5MT0FERUQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnN0YXR1cyA9PT0gUmVzb3VyY2VTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuc3RhdHVzID09PSBSZXNvdXJjZVN0YXRlLlRJTUVPVVQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAvLyBpbmZvIGFib3V0IHRoZSByZXNvdXJjZSB0aGF0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogdXBkYXRlZEVudHJ5LnJlc291cmNlLFxuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdlIGV4cG9zZSBTdGF0dXNUeXBlIGluc3RlYWQ/XG4gICAgICAgICAgICAgICAgbG9hZGVkOiAodXBkYXRlZEVudHJ5LnN0YXR1cyA9PT0gUmVzb3VyY2VTdGF0ZS5MT0FERUQpLFxuICAgICAgICAgICAgICAgIGVycm9yOiAodXBkYXRlZEVudHJ5LnN0YXR1cyA9PT0gUmVzb3VyY2VTdGF0ZS5FUlJPUiksXG4gICAgICAgICAgICAgICAgdGltZW91dDogKHVwZGF0ZWRFbnRyeS5zdGF0dXMgPT09IFJlc291cmNlU3RhdGUuVElNRU9VVCksXG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIHN0YXRzIGZvciBhbGwgcmVzb3VyY2VzXG4gICAgICAgICAgICAgICAgY29tcGxldGVkQ291bnQ6IGNvbXBsZXRlZCxcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50OiB0b3RhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHJpbnRzIHRoZSBzdGF0dXMgb2YgZWFjaCByZXNvdXJjZSB0byB0aGUgY29uc29sZVxuICAgICAgICB2YXIgbG9nID0gdGhpcy5sb2cgPSBmdW5jdGlvbihzaG93QWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxhcHNlZFNlY29uZHMgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gdGltZVN0YXJ0ZWQpIC8gMTAwMCk7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ1B4TG9hZGVyIGVsYXBzZWQ6ICcgKyBlbGFwc2VkU2Vjb25kcyArICcgc2VjJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3dBbGwgJiYgZW50cnkuc3RhdHVzICE9PSBSZXNvdXJjZVN0YXRlLldBSVRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnUHhMb2FkZXI6ICMnICsgaSArICcgJyArIGVudHJ5LnJlc291cmNlLmdldE5hbWUoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2goZW50cnkuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VTdGF0ZS5RVUVVRUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICcgKE5vdCBTdGFydGVkKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVN0YXRlLldBSVRJTkc6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICcgKFdhaXRpbmcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFJlc291cmNlU3RhdGUuTE9BREVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnIChMb2FkZWQpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFJlc291cmNlU3RhdGUuRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICcgKEVycm9yKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVN0YXRlLlRJTUVPVVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICcgKFRpbWVvdXQpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5yZXNvdXJjZS50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnIFRhZ3M6IFsnICsgZW50cnkucmVzb3VyY2UudGFncy5hbGwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIFRhZyBvYmplY3QgdG8gaGFuZGxlIHRhZyBpbnRlcnNlY3Rpb247IG9uY2UgY3JlYXRlZCBub3QgbWVhbnQgdG8gYmUgY2hhbmdlZFxuICAgIC8vIFBlcmZvcm1hbmNlIHJhdGlvbmFsZTogaHR0cDovL2pzcGVyZi5jb20vbGlzdHMtaW5kZXhvZi12cy1pbi1vcGVyYXRvci8zXG5cbiAgICBmdW5jdGlvbiBQeExvYWRlclRhZ3ModmFsdWVzKSB7XG5cbiAgICAgICAgdGhpcy5hbGwgPSBbXTtcbiAgICAgICAgdGhpcy5maXJzdCA9IG51bGw7IC8vIGNhY2hlIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgLy8gaG9sZHMgdmFsdWVzIGFzIGtleXMgZm9yIHF1aWNrIGxvb2t1cFxuICAgICAgICB0aGlzLmxvb2t1cCA9IHt9O1xuXG4gICAgICAgIGlmICh2YWx1ZXMpIHtcblxuICAgICAgICAgICAgLy8gZmlyc3QgZmlsbCB0aGUgYXJyYXkgb2YgYWxsIHZhbHVlc1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGFycmF5IG9mIHZhbHVlcywganVzdCB0byBiZSBzYWZlXG4gICAgICAgICAgICAgICAgdGhpcy5hbGwgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGwucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbC5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBsZW5ndGggYW5kIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmFsbC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdCA9IHRoaXMuYWxsWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgdmFsdWVzIGFzIG9iamVjdCBrZXlzIGZvciBxdWljayBsb29rdXAgZHVyaW5nIGludGVyc2VjdGlvbiB0ZXN0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb2t1cFt0aGlzLmFsbFtpXV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0aGlzIG9iamVjdCB3aXRoIGFub3RoZXI7IHJldHVybiB0cnVlIGlmIHRoZXkgc2hhcmUgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgUHhMb2FkZXJUYWdzLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24ob3RoZXIpIHtcblxuICAgICAgICAvLyBoYW5kbGUgZW1wdHkgdmFsdWVzIGNhc2VcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwIHx8IG90aGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBhIHNpbmdsZSB2YWx1ZSB0byBjb21wYXJlP1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgb3RoZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdCA9PT0gb3RoZXIuZmlyc3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZXR0ZXIgdG8gbG9vcCB0aHJvdWdoIHRoZSBzbWFsbGVyIG9iamVjdFxuICAgICAgICBpZiAob3RoZXIubGVuZ3RoIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5pbnRlcnNlY3RzKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGV2ZXJ5IGtleSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBtYXRjaGVzXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxvb2t1cCkge1xuICAgICAgICAgICAgaWYgKG90aGVyLmxvb2t1cFtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBQeExvYWRlcjtcbn0pKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxhQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pxloader/PxLoader.js\n");

/***/ }),

/***/ "./node_modules/pxloader/PxLoader.js-exposed":
/*!***************************************************!*\
  !*** ./node_modules/pxloader/PxLoader.js-exposed ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"PxLoader\"] = __webpack_require__(/*! -!./PxLoader.js */ \"./node_modules/pxloader/PxLoader.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHhsb2FkZXIvUHhMb2FkZXIuanMtZXhwb3NlZC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9weGxvYWRlci9QeExvYWRlci5qcy1leHBvc2VkP2VlZGYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxbXCJQeExvYWRlclwiXSA9IHJlcXVpcmUoXCItIS5cXFxcUHhMb2FkZXIuanNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pxloader/PxLoader.js-exposed\n");

/***/ }),

/***/ "./node_modules/pxloader/PxLoaderImage.js":
/*!************************************************!*\
  !*** ./node_modules/pxloader/PxLoaderImage.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// PxLoader plugin to load images\n(function(root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! pxloader */ \"./node_modules/pxloader/PxLoader.js-exposed\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(PxLoader) {\n            return (root.PxLoaderImage = factory(PxLoader));\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function(PxLoader) {\n    function PxLoaderImage(url, tags, priority, options) {\n        options = options || {};\n        \n        var self = this,\n            loader = null,\n            img;\n\n        img = this.img = new Image();\n        if (options.origin) {\n            img.crossOrigin = options.origin;\n        }\n\n        this.tags = tags;\n        this.priority = priority;\n\n        var onReadyStateChange = function() {\n            if (self.img.readyState !== 'complete') {\n                return;\n            }\n\n            onLoad();\n        };\n\n        var onLoad = function() {\n            loader.onLoad(self);\n            cleanup();\n        };\n\n        var onError = function() {\n            loader.onError(self);\n            cleanup();\n        };\n        \n        var onTimeout = function() {\n            loader.onTimeout(self);\n            cleanup();\n        };\n\n        var cleanup = function() {\n            self.unbind('load', onLoad);\n            self.unbind('readystatechange', onReadyStateChange);\n            self.unbind('error', onError);\n        };\n\n        this.start = function(pxLoader) {\n            // we need the loader ref so we can notify upon completion\n            loader = pxLoader;\n\n            // NOTE: Must add event listeners before the src is set. We\n            // also need to use the readystatechange because sometimes\n            // load doesn't fire when an image is in the cache.\n            self.bind('load', onLoad);\n            self.bind('readystatechange', onReadyStateChange);\n            self.bind('error', onError);\n\n            self.img.src = url;\n        };\n\n        // called by PxLoader to check status of image (fallback in case\n        // the event listeners are not triggered).\n        this.checkStatus = function() {\n            onReadyStateChange();\n        };\n\n        // called by PxLoader when it is no longer waiting\n        this.onTimeout = function() {\n            if (self.img.complete) {\n                onLoad();\n            } else {\n                onTimeout();\n            }\n        };\n\n        // returns a name for the resource that can be used in logging\n        this.getName = function() {\n            return url;\n        };\n\n        // cross-browser event binding\n        this.bind = function(eventName, eventHandler) {\n            self.img.addEventListener(eventName, eventHandler, false);\n        };\n\n        // cross-browser event un-binding\n        this.unbind = function(eventName, eventHandler) {\n            self.img.removeEventListener(eventName, eventHandler, false);\n        };\n\n    }\n\n    // add a convenience method to PxLoader for adding an image\n    PxLoader.prototype.addImage = function(url, tags, priority, options) {\n        var imageLoader = new PxLoaderImage(url, tags, priority, options);\n        this.add(imageLoader);\n\n        // return the img element to the caller\n        return imageLoader.img;\n    };\n\n    return PxLoaderImage;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHhsb2FkZXIvUHhMb2FkZXJJbWFnZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9weGxvYWRlci9QeExvYWRlckltYWdlLmpzPzExYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHhMb2FkZXIgcGx1Z2luIHRvIGxvYWQgaW1hZ2VzXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoWydweGxvYWRlciddLCBmdW5jdGlvbihQeExvYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIChyb290LlB4TG9hZGVySW1hZ2UgPSBmYWN0b3J5KFB4TG9hZGVyKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdweGxvYWRlcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgcm9vdC5QeExvYWRlckltYWdlID0gZmFjdG9yeShyb290LlB4TG9hZGVyKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKFB4TG9hZGVyKSB7XG4gICAgZnVuY3Rpb24gUHhMb2FkZXJJbWFnZSh1cmwsIHRhZ3MsIHByaW9yaXR5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbG9hZGVyID0gbnVsbCxcbiAgICAgICAgICAgIGltZztcblxuICAgICAgICBpbWcgPSB0aGlzLmltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW4pIHtcbiAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuXG4gICAgICAgIHZhciBvblJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmltZy5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsb2FkZXIub25Mb2FkKHNlbGYpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsb2FkZXIub25FcnJvcihzZWxmKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBvblRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvYWRlci5vblRpbWVvdXQoc2VsZik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYudW5iaW5kKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgIHNlbGYudW5iaW5kKCdyZWFkeXN0YXRlY2hhbmdlJywgb25SZWFkeVN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIHNlbGYudW5iaW5kKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbihweExvYWRlcikge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgbG9hZGVyIHJlZiBzbyB3ZSBjYW4gbm90aWZ5IHVwb24gY29tcGxldGlvblxuICAgICAgICAgICAgbG9hZGVyID0gcHhMb2FkZXI7XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IE11c3QgYWRkIGV2ZW50IGxpc3RlbmVycyBiZWZvcmUgdGhlIHNyYyBpcyBzZXQuIFdlXG4gICAgICAgICAgICAvLyBhbHNvIG5lZWQgdG8gdXNlIHRoZSByZWFkeXN0YXRlY2hhbmdlIGJlY2F1c2Ugc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBsb2FkIGRvZXNuJ3QgZmlyZSB3aGVuIGFuIGltYWdlIGlzIGluIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIHNlbGYuYmluZCgnbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICBzZWxmLmJpbmQoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBvblJlYWR5U3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgc2VsZi5iaW5kKCdlcnJvcicsIG9uRXJyb3IpO1xuXG4gICAgICAgICAgICBzZWxmLmltZy5zcmMgPSB1cmw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsbGVkIGJ5IFB4TG9hZGVyIHRvIGNoZWNrIHN0YXR1cyBvZiBpbWFnZSAoZmFsbGJhY2sgaW4gY2FzZVxuICAgICAgICAvLyB0aGUgZXZlbnQgbGlzdGVuZXJzIGFyZSBub3QgdHJpZ2dlcmVkKS5cbiAgICAgICAgdGhpcy5jaGVja1N0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgb25SZWFkeVN0YXRlQ2hhbmdlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY2FsbGVkIGJ5IFB4TG9hZGVyIHdoZW4gaXQgaXMgbm8gbG9uZ2VyIHdhaXRpbmdcbiAgICAgICAgdGhpcy5vblRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvblRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGEgbmFtZSBmb3IgdGhlIHJlc291cmNlIHRoYXQgY2FuIGJlIHVzZWQgaW4gbG9nZ2luZ1xuICAgICAgICB0aGlzLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3Jvc3MtYnJvd3NlciBldmVudCBiaW5kaW5nXG4gICAgICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBzZWxmLmltZy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3Jvc3MtYnJvd3NlciBldmVudCB1bi1iaW5kaW5nXG4gICAgICAgIHRoaXMudW5iaW5kID0gZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNlbGYuaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIC8vIGFkZCBhIGNvbnZlbmllbmNlIG1ldGhvZCB0byBQeExvYWRlciBmb3IgYWRkaW5nIGFuIGltYWdlXG4gICAgUHhMb2FkZXIucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24odXJsLCB0YWdzLCBwcmlvcml0eSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW1hZ2VMb2FkZXIgPSBuZXcgUHhMb2FkZXJJbWFnZSh1cmwsIHRhZ3MsIHByaW9yaXR5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGQoaW1hZ2VMb2FkZXIpO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW1nIGVsZW1lbnQgdG8gdGhlIGNhbGxlclxuICAgICAgICByZXR1cm4gaW1hZ2VMb2FkZXIuaW1nO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHhMb2FkZXJJbWFnZTtcbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLGFBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pxloader/PxLoaderImage.js\n");

/***/ })

}]);